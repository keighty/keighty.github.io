<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Oop | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/oop/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2015-01-20T07:40:43-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objects vs Data Structures]]></title>
    <link href="http://www.katieleonard.ca/blog/2015/objects-vs-data-structures/"/>
    <updated>2015-01-18T00:00:00-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2015/objects-vs-data-structures</id>
    <content type="html"><![CDATA[<p>&ldquo;It is impossible to create an abstraction unknowingly or by accident,&rdquo; says Sandi Metz in <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_1?ie=UTF8&amp;qid=1421723392&amp;sr=8-1&amp;keywords=practical+object+oriented+design+in+ruby"><em>Practical Object Oriented Design in Ruby</em></a>. An abstraction is a common, stable quality, such that you would find in a java interface. An interface is an idea that cannot be made concrete, but contains behaviour <a href="http://en.wikipedia.org/wiki/Interface_%28Java%29">encode similarities</a> which objects might share. Even the definition of abstraction is abstract. I wasn&rsquo;t until I read Robert C. Martin&rsquo;s chapter on Objects and Data Structures in <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><em>Clean Code</em></a> that I really started to understand them.</p>

<!--more-->


<h3>What is a data structure</h3>

<p>A data structure is a class that exposes its data to the public. It should have no meaningful behaviour, and can be characterized by a set of attributes along with getters and setters.</p>

<p>{% codeblock lang:ruby Point as data structure %}
class Point1
  attr_accessor :x, :y, :z
end</p>

<p>p = Point1.new
p.x = 1
p.y = 1
p.z = 1
p
=> #&lt;Point1:0x007f86092452e8 @x=1, @y=1, @z=1>
{% endcodeblock %}</p>

<p>In this example, a Point is defined as an object at some location on a coordinate grid of some kind. That sounds abstract enough: you can create a point, {% pullquote %}access all of the point&rsquo;s data, and set its location along each axis independently. You have an instance of a point, but it is not an abstraction of a point &mdash; it is a data structure. {&ldquo;Hiding implementation is not about putting a layer of functions between the variables. It is about abstractions.&rdquo;}
{% endpullquote %} Adding an initializer that sets each variable, or a <code>to_s</code> method for getting a pretty output, would not make the Point1 class any more an abstraction of a position in space. To make an abstraction you can&rsquo;t just use getters and setters &mdash; you have to think about how you are representing the data.</p>

<h3>What is an object</h3>

<p>An object hides its data behind abstractions. A Point is not defined by its <code>[@x, @y, @z]</code>, but by its location in space. If space is a coordinate system, it could be 2- or 3-dimensional.</p>

<p>{% codeblock Point as abstraction %}
class Point2
  def initialize(x, y, z = nil)</p>

<pre><code>set_location(x, y, z)
</code></pre>

<p>  end</p>

<p>  def to_s</p>

<pre><code>"(#{[@x, @y, @z].compact.join(',')})"
</code></pre>

<p>  end
  alias_method :location, :to_s</p>

<p>  def set_location(x, y, z = nil)</p>

<pre><code>@x = x
@y = y
@z = z
location
</code></pre>

<p>  end
  private :set_location</p>

<p>  alias_method :move_point, :set_location
  public :move_point</p>

<p>end</p>

<p>p = Point2.new(1, 1)
=> #&lt;Point2:0x007fca39927038 @x=1, @y=1, @z=nil>
p.move_point(2, 3)
=> &ldquo;(2,3)&rdquo;
p.move_point(2, 3, 7)
=> &ldquo;(2,3,7)&rdquo;
{% endcodeblock %}</p>

<p>A point cannot exist separate from it&rsquo;s coordinates, and coordinates cannot exist or be altered without using the abstraction of moving in space.</p>

<blockquote><p>&ldquo;We do not want to expose the details of our data. Rather we want to express our data in abstract terms. This is not merely accomplished by using interfaces and/or getters and setters. Serious thought needs to be put into the best way to represent the data that an object contains.&rdquo;</p>

<p>&mdash; Martin</p></blockquote>

<p>This is why <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">fat models are an anti-pattern in Rails</a>. ActiveRecord makes an object out of a data structure, and adding behaviour beyond data validation makes the model a hybrid data object. <a href="http://railscasts.com/episodes/398-service-objects">Service Objects</a> are abstractions of model behaviour (pun intended).</p>

<p>Now I know what an abstraction is, and I understand that simply extracting methods into interfaces doesn&rsquo;t magically make an abstraction. As Metz says, &ldquo;good design naturally progresses toward small independent objects that rely on abstractions.&rdquo; An object is more than a data structure; it is an idea and it must be applied deliberately.</p>

<!-- resources
http://www.cgore.com/programming/ruby/public-aliases-of-private-methods.lisp
-->


<!-- resources
http://railscasts.com/episodes/398-service-objects
http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/
-->

]]></content>
  </entry>
  
</feed>
