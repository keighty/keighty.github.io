<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2014-02-13T19:43:36-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Execution]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/ruby-execution/"/>
    <updated>2013-09-10T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/ruby-execution</id>
    <content type="html"><![CDATA[<p>I have started including an executable in my project setup. Many of the code challenges I have been practicing lately have included file I/O, and while TDD and code exercising with RSpec is still my main process, developing a stand-alone fully-functional project requires something more.</p>

<!--more-->


<h3>Blocks Code Challenge</h3>

<p>I found the blocks code challenge on the <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=37">UVa code competition website</a>. To sum up, you have to write a program that will parse and carry out a series of commands for stacking blocks.</p>

<ol>
<li>move a onto b</li>
<li>move a over b</li>
<li>pile a onto b</li>
<li>pile a over b</li>
<li>quit</li>
</ol>


<p>The commands will be provided in an input file, and an output is specified. Fun problem, right? So, I start my project folder using my <a href="http://www.katieleonard.ca/automation/2013/09/08/thor-sets-up-a-project/">thor task</a>, and work awhile adding logic and tests and data as appropriate. My file tree finishes like this:
{% highlight bash %}
blocks
├── data
│   ├── input.txt
│   └── output.txt
├── lib
│   └── blocks.rb
├── spec
│   ├── blocks_spec.rb
│   └── spec_helper.rb
├── Gemfile
└── README.md{% endhighlight %}</p>

<p>So, in order to use my script, I would have to call it from the command line:
{% highlight bash %}
$ ruby lib/blocks.rb data/input.txt</p>

<h1>=> or</h1>

<p>$ data/input.txt | ruby lib/blocks.rb{% endhighlight %}</p>

<p>This is an extremely verbose way to deliver a final product, and I would much rather call $ blocks &lt;file_input&gt;. It turns out that making an executable is easy and elegant, just like everything else in ruby. You just have to declare the ruby environment, include a few notes on usage, load the file tree, and call the class:
{% highlight ruby %}</p>

<h1>!/usr/bin/env ruby</h1>

<h1>blocks</h1>

<h1>10-Sep-2013</h1>

<p>#</p>

<h1>Usage:</h1>

<h1>./blocks data/input.txt</h1>

<p>#
$LOAD_PATH.unshift(File.join(File.dirname(<strong>FILE</strong>), &lsquo;lib&rsquo;))
require &lsquo;blocks&rsquo;
Blocks.new.process_input{% endhighlight %}</p>

<p>Placing this code in a non-extension file, like &lsquo;blocks&rsquo;, in the main directory, I can make it an executable by changing the file permissions:
{% highlight bash %}
$ chmod +x ./blocks{% endhighlight %}</p>

<p>And I can call it like any other executable:
{% highlight bash %}
$ ./blocks data/input.txt{% endhighlight %}</p>

<p>I liked this solution so much, I added it to my thor project setup! Oh, and if you are interested in seeing my solution for the blocks problem, checkout my <a href="https://github.com/keighty/datastructures/tree/master/ruby/blocks">github repo</a></p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thor Sets Up a Project]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/thor-sets-up-a-project/"/>
    <updated>2013-09-08T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/thor-sets-up-a-project</id>
    <content type="html"><![CDATA[<p>A few weeks ago I posted about <a href="http://www.katieleonard.ca/automation/2013/08/30/hammer-out-tasks-with-thor/">using Thor to generate system-wide notes files with a standard format</a>. Since then, I have been doing a lot of smaller code challenges, and I wanted to set up a Thor task for generating a standard project file tree.</p>

<!--more-->


<p>My Goal Tree:
{% highlight bash %}
project_name
├── lib
│   └── project_name.rb
├── spec
│   ├── project_name_spec.rb
│   └── spec_helper.rb
├── Gemfile
└── README.md{% endhighlight %}</p>

<p>I always begin with these files and this organization. A Gemfile and README are essential for setting up the environment and explaining the gist of the project. I am most comfortable with RSpec, and to get into the practice of TDD, setting up a testing environment right away is non-negotiable. All of these standard files contain some automatic content as well:</p>

<h5>spec_helper.rb loads the library</h5>

<p>{% highlight ruby %}
$LOAD_PATH.unshift(File.join(File.dirname(<strong>FILE</strong>), &lsquo;..&rsquo;, &lsquo;lib&rsquo;))
require &lsquo;rspec&rsquo;
require &lsquo;project_name&rsquo;
{% endhighlight %}</p>

<h5>project_name_spec.rb sets up the first test</h5>

<p>{% highlight ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe ProjectName do
  before (:each) {  }
  subject {  }</p>

<p>  it &ldquo;should pass&rdquo;
end
{% endhighlight %}</p>

<h5>Gemfile specifies the right gems for setting up the project</h5>

<p>{% highlight ruby %}
ruby &lsquo;2.0.0&rsquo;
gem &lsquo;rspec&rsquo;
{% endhighlight %}</p>

<p>There are other files that could have auto-generated content as well, like a Rakefile, or a config.ru, but this is a good start.</p>

<h4>Create a Thor task (rb_project.thor):</h4>

<p>{% highlight ruby %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &ldquo;rubygems&rdquo;
require &ldquo;thor&rdquo;</p>

<p>class RbProject &lt; Thor
  desc &ldquo;init&rdquo;, &ldquo;creates a ruby project with rspec&rdquo;</p>

<p>  def init(title=&ldquo;new_project&rdquo;)</p>

<pre><code>Dir.mkdir(title)
Dir.chdir(title)
Dir.mkdir("spec")
Dir.mkdir("lib")
filename = "#{title}"

open(File.new("README.md", "w"), "w") do |note|
  note.puts "# #{title}"
end

open(File.new("Gemfile", "w"), "w") do |my_gem|
  my_gem.puts "ruby '2.0.0'"
  my_gem.puts "gem 'rspec'"
end

open(File.new("spec/spec_helper.rb", "w"), "w") do |spec|
  spec.puts "$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))"
  spec.puts "require 'rspec'"
  spec.puts "require '#{filename}'"
end

open(File.new("spec/#{filename}_spec.rb", "w"), "w") do |spec|
  spec.puts "require 'spec_helper'"
  spec.puts ""
  spec.puts "describe #{camelize(filename)} do"
  spec.puts "  before (:each) {  }"
  spec.puts "  xit 'should pass'"
  spec.puts "end"
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def camelize(snake)
  title = snake.split('_').each do |word|
    word.capitalize!
  end
  title.join('')
end
</code></pre>

<p>end {% endhighlight %}</p>

<p>I created a private method camelize in order to change the snake_case project name into a CamelCase class name.</p>

<p>As before, I install my thor task system wide:
{% highlight bash %}
$ thor install rb_project.thor {% endhighlight %}</p>

<p>And now my project generation task can be run from any directory, anywhere on my system:
{% highlight bash %}
$ thor list</p>

<h2>note</h2>

<p>thor note:create  # creates a notes file in markdown</p>

<h2>rb_project</h2>

<p>thor rb_project:init  # creates a ruby project with rspec</p>

<p>$ thor rb_project:init test_project
$ tree test_project/
test_project/
├── lib
│   └── test_project.rb
├── spec
│   ├── spec_helper.rb
│   └── test_project_spec.rb
├── Gemfile
├── README.md</p>

<p>2 directories, 6 files
{% endhighlight %}</p>

<p>Awesome.</p>

<p>{% highlight bash %}{% endhighlight %}
{% highlight bash %}{% endhighlight %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARGF All You Want]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/argf-all-you-want/"/>
    <updated>2013-09-05T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/argf-all-you-want</id>
    <content type="html"><![CDATA[<p>Many of the fun, junior code challenges I have encountered deal a lot with input/output of data, and I found a great ruby feature that provides flexibility at the command line.</p>

<!--more-->


<h3>Data Input</h3>

<p>There are a lot of ways to treat data at the command line, but the one I was most familiar with is passing in a filename as an argument:</p>

<p>{% highlight bash linenos%}
$ ruby example_script.rb file1.csv file2.csv &hellip;
$ ruby example_script.rb file1.csv | more
$ ruby example_script.rb file1.csv > output.txt{% endhighlight %}</p>

<h3>Filename Input</h3>

<p>Using ARGV, we can access the list of filenames provided at the command line. ARGV is an array containing all the information that follows the command. For example:
{% highlight bash %}
$ example_command apple banana orange</p>

<h1>ARGV = [&ldquo;apple&rdquo;, &ldquo;banana&rdquo;, &ldquo;orange&rdquo;]{% endhighlight %}</h1>

<p>One can process each filename in ARGV using regular array methods:</p>

<p>{% highlight ruby %}
ARGV.each do |arg|
  process_string(File.read(arg))
end {% endhighlight %}</p>

<p>File.read(arg) reads the file into a &ldquo;\n&rdquo; delimited string, which can be processed further. If there are no arguments, ARGV is an empty array.</p>

<h3>Piped Input</h3>

<p>Say that we want to enter data directly into a program rather than use a fixed filename at the command line &mdash; a useful technique for when we want data to flow out of one process and into another:
{% highlight bash %}
$ cat file1.csv | ruby example_script.rb
$ cat *.csv | ruby example_script.rb
$ ruby example_script.rb &lt; file1.csv {% endhighlight %}</p>

<p>Using the pipe, &ldquo;|&rdquo; or &ldquo;&lt;&rdquo;, we can push a string of data from one process into another, but what happens to our program when we try to do this?
{% highlight bash %}
$ example.csv | ruby example_script.rb
TypeError: can`t convert nil into String {% endhighlight %}</p>

<p>We get a TypeError! Recall that command line arguments are stored in ARGV, but we are not providing any command line arguments. ARGV is an empty array, and we are attempting to open a file from ARGV[0] = nil. Shame on us! How do we access data that is piped in as well as data that is appended to the command line? Do we have to check for the source of the data before we can treat it? Turns out, we DON&rsquo;T.</p>

<h3>The ARGF Solution</h3>

<p>Ruby has a nifty interface for handling data input, regardless of whether it arrives as a command line argument or from another data source. We can replace the code we wrote earlier with a single line:</p>

<p>{% highlight ruby%}
process_string(ARGF.read){% endhighlight %}</p>

<p>If ARGV is not empty, ARGF will assume it is an array of filenames and will treat them accordingly. If ARGV is empty, it will read from $stdin to get the data passed in via the pipe. One caveat is that you can&rsquo;t read from both ARGV and the pipe: if ARGV != [  ], $stdin is ignored.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hammer-out Tasks With Thor]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/hammer-out-tasks-with-thor/"/>
    <updated>2013-08-30T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/hammer-out-tasks-with-thor</id>
    <content type="html"><![CDATA[<p>A few months ago I gave a small lightning talk to my code school class about automating tasks using <a href="http://rake.rubyforge.org/">Rake</a>. Before I learned ruby I used bash scripts to accomplish similar things, but was often bogged down in learning the syntax of string-processing essentials like awk or sed. I wished for the simplicity of Ruby, and thought that Rake was the bees-knees. After my talk, <a href="chuckvose.com">Chuck</a>, my PCS mentor, put together a repo of <a href="http://whatisthor.com/">Thor</a> tasks that accomplished the same tasks but could be installed system wide.</p>

<!--more-->


<h3><a href="http://whatisthor.com/">Thor</a> is my new hero</h3>

<p>Unlike Rake tasks, which are confined to the directory containing the Rakefile, Thor tasks can be installed on your system and called from anywhere. My note files are all formatted in a particular way. Before Thor, I used a rake task:</p>

<p>{% highlight bash %}
$ cd notesDirWithRakefile
$ rake post title=&ldquo;new post title&rdquo;
$ Creating new post: &ldquo;./130830_new_post_title&rdquo;{% endhighlight %}</p>

<p>The Rake task auto-formats the filename, replacing spaces with underscores, and prepends today&rsquo;s date so that they will sort in the order they are made. This worked great for when I wanted to keep notes in that one folder, but later I wanted to be able to keep notes on a particular project. I would either have to copy the Rakefile (two places to update if I made any changes), or create a symbolic link (which would break if I ever moved my Rakefile). Neither of these options seemed to be the most practical. Enter Thor:</p>

<p>Creating the Thor task is as easy as pie:
{% highlight ruby %}
require &lsquo;thor&rsquo;</p>

<p>class Note &lt; Thor
  desc &ldquo;create&rdquo;, &ldquo;creates a notes file in markdown&rdquo;
  def create(title=&ldquo;new note&rdquo;)</p>

<pre><code>slug = title.downcase.strip.gsub(' ', '_').gsub(/[^\w-]/, '')
date = Time.parse(Time.now).strftime('%y%m%d')
filename = File.join("./", "#{date}_#{slug}.md")

if File.exist?(filename)
  abort("rake aborted!") if ask("#{filename} already exists. Do you want to overwrite?", ['y', 'n']) == 'n'
end

puts "Creating new post: #{filename}"
open(filename, 'w') do |post|
  post.puts "# #{title.gsub(/-/,' ').capitalize}"
end
</code></pre>

<p>  end
end {% endhighlight %}</p>

<p>Listing all Thor tasks is easy:
{% highlight bash %}
$ thor list</p>

<h2>note</h2>

<p>thor note:create  # creates a notes file in markdown {% endhighlight %}</p>

<p>Installing a Thor task for system use is easy:
{% highlight bash %}
$ thor install notes.thor
&hellip;
Do you wish to continue [y/N]? y
Please specify a name for notes.thor in the system repository [notes.thor]: note
Storing thor file in your system repository {% endhighlight %}</p>

<p>Uninstalling a Thor task is easy:
{% highlight bash %}
$ thor uninstall note
Uninstalling note.
Done. {% endhighlight %}</p>

<p>With my Thor notes task installed system-wide, I can create a note page in any directory, for any reason, without copying code.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[State of the QuickUnion]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/state-of-the-quickunion/"/>
    <updated>2013-08-04T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/state-of-the-quickunion</id>
    <content type="html"><![CDATA[<p>In my last look at the UnionFind algorithm I made a quick-find implementation &mdash; finding if two elements were connected was fast but connecting two elements was slow. The union operation is a good candidate for optimization.</p>

<!--more-->


<h1>Quick Union</h1>

<p>One way to optimize the union operation is to reduce the number of array accesses required.</p>

<p>In QuickFind, the sets are arranged in a flat array of elements which all share the same value: they are all wearing the same t-shirt. When we connect elements from different sets, we must make sure that every element in the first set changes its t-shirt to match the elements in the other set. This is a time-consuming process, and uses a lot of t-shirts.</p>

<p>What if only one element had to change its t-shirt? If the set had a single element in charge &ndash; a root &ndash; then joining elements from different sets would require identifying the t-shirt of the one in charge, and then changing to that element&rsquo;s t-shirt.</p>

<p>Using an array instead of t-shirts to keep track of the values, we can walk through what this implementation would look like:</p>

<table class="table table-bordered">
  <tr>
    <th>Index</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <th></th>
  </tr>
  <tr>
    <th>Value</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <td> | Each element begins as the root of its own set</td>
  </tr>
  <tr>
    <th>union(4,9)</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td class="highlight">9</td>
    <td>0</td>
    <td> | root(9) = 9, root(4) = 4, change array[4] = 9</td>
  </tr>
  <tr>
    <th>union(2,4)</th>
    <td>1</td>
    <td class="highlight">9</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <td> | root(4) = 9, root(2) = 2, change array[2] = 9</td>
  </tr>
  <tr>
    <th>union(4,7)</th>
    <td>1</td>
    <td>9</td>
    <td>3</td>
    <td  class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td  class="highlight">7</td>
    <td>8</td>
    <td>7</td>
    <td>0</td>
    <td> | root(7) = 7, root(4) = 9, change array[9] = 7</td>
  </tr>
  <tr>
    <th>find(2,7)</th>
    <td>1</td>
    <td class="highlight">9</td>
    <td>3</td>
    <td>9</td>
    <td>5</td>
    <td>6</td>
    <td class="highlight">7</td>
    <td>8</td>
    <td class="highlight">7</td>
    <td>0</td>
    <td> | root(7) = 7, root(2) = 7. The two are connected </td>
  </tr>
</table>


<h2>QuickUnion</h2>

<p>Again following the basic API:
{% highlight java %}</p>

<h2>public class UF</h2>

<p>public UF(int N)
public int find(int p, int q)
public void union(int p, int q){% endhighlight %}</p>

<p>I adapted the QuickUnion in ruby:
{% highlight ruby linenos %}
class QuickUnion
  def initialize(size)</p>

<pre><code>@find_array = Array.new(size){ |index| index }
</code></pre>

<p>  end</p>

<p>  # check if p and q have the same root
  def find(p, q)</p>

<pre><code>verify(p, q)
root(p) == root(q)
</code></pre>

<p>  end</p>

<p>  # set id of p&rsquo;s root to the id of q&rsquo;s root
  def union(p, q)</p>

<pre><code>verify(p, q)
@find_array[root(p)] = root(q)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def root(index)
  # get root until root(index) == index
  if @find_array[index] == index
    return index
  else
    root(@find_array[index])
  end
end

def verify(p, q)
  raise NotAnElement if @find_array[p].nil?
  raise NotAnElement if @find_array[q].nil?
end
</code></pre>

<p>end</p>

<p>class NotAnElement &lt; Exception
end
{% endhighlight %}</p>

<p>This implementation is a QuickUnion because in an array of 1,000,000 entries, connecting element p to element q is easy: you only have to find the root of p, and then change q to match (one root() and one array access). Finding if p and q are connected takes a little bit longer, because you have to perform two root operations: one for p and one for q, but it is still faster than accessing every element in the array.</p>

<h2>Benchmark</h2>

<p>{% highlight bash %}
$ ruby lib/benchmark.rb
=> Array Size: 100</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.000000   0.000000   0.000000 (  0.001865)
   0.000000   0.000000   0.000000 (  0.000377)
$ ruby lib/benchmark.rb
=> Array Size: 1000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.120000   0.010000   0.130000 (  0.124929)
   0.010000   0.000000   0.010000 (  0.008825)
$ ruby lib/benchmark.rb
=> Array Size: 10000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>  10.120000   0.030000  10.150000 ( 10.146124)
   0.520000   0.000000   0.520000 (  0.520377){% endhighlight %}</p>

<p>Comparing QuickFind (top line) with QuickUnion(bottom line), we can actually measure how well this small optimization of the union operation has increased performance with larger datasets.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
</feed>
