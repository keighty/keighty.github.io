<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2015-02-24T08:26:12-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objects vs Data Structures]]></title>
    <link href="http://www.katieleonard.ca/blog/2015/objects-vs-data-structures/"/>
    <updated>2015-01-18T00:00:00-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2015/objects-vs-data-structures</id>
    <content type="html"><![CDATA[<p>&ldquo;It is impossible to create an abstraction unknowingly or by accident,&rdquo; says Sandi Metz in <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_1?ie=UTF8&amp;qid=1421723392&amp;sr=8-1&amp;keywords=practical+object+oriented+design+in+ruby"><em>Practical Object Oriented Design in Ruby</em></a>. An abstraction is a common, stable quality, such that you would find in a java interface. An interface is an idea that cannot be made concrete, but contains behaviour <a href="http://en.wikipedia.org/wiki/Interface_%28Java%29">encoding similarities</a> which objects might share. Even the definition of abstraction is abstract, and it wasn&rsquo;t until I read Robert C. Martin&rsquo;s chapter on Objects and Data Structures in <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><em>Clean Code</em></a> that I really started to understand them.</p>

<!--more-->


<h3>What is a data structure</h3>

<p>A data structure is a class that exposes its data to the public. It should have no meaningful behaviour, and can be characterized by a set of attributes along with getters and setters.</p>

<p>```ruby
class Point1
  attr_accessor :x, :y, :z
end</p>

<p>p = Point1.new
p.x = 1
p.y = 1
p.z = 1
p
```</p>

<p>In this example, a Point is defined as an object at some location on a coordinate grid of some kind. That sounds abstract enough: you can create a point, Surround your pullquote like this {" text to be quoted "} Adding an initializer that sets each variable, or a <code>to_s</code> method for getting a pretty output, would not make the Point1 class any more an abstraction of a position in space. To make an abstraction you can&rsquo;t just use getters and setters &mdash; you have to think about how you are representing the data.</p>

<h3>What is an object</h3>

<p>An object hides its data behind abstractions. A Point is not defined by its <code>[@x, @y, @z]</code>, but by its location in space. If space is a coordinate system, it could be 2- or 3-dimensional.</p>

<p>```
class Point2
  def initialize(x, y, z = nil)</p>

<pre><code>set_location(x, y, z)
</code></pre>

<p>  end</p>

<p>  def to_s</p>

<pre><code>"(#{[@x, @y, @z].compact.join(',')})"
</code></pre>

<p>  end
  alias_method :location, :to_s</p>

<p>  def set_location(x, y, z = nil)</p>

<pre><code>@x = x
@y = y
@z = z
location
</code></pre>

<p>  end
  private :set_location</p>

<p>  alias_method :move_point, :set_location
  public :move_point</p>

<p>end</p>

<p>p = Point2.new(1, 1)
p.move_point(2, 3)
p.move_point(2, 3, 7)
```</p>

<p>A point cannot exist separate from it&rsquo;s coordinates, and coordinates cannot exist or be altered without using the abstraction of moving in space.</p>

<blockquote><p>&ldquo;We do not want to expose the details of our data. Rather we want to express our data in abstract terms. This is not merely accomplished by using interfaces and/or getters and setters. Serious thought needs to be put into the best way to represent the data that an object contains.&rdquo;</p>

<p>&mdash; Martin</p></blockquote>

<p>This is why <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">fat models are an anti-pattern in Rails</a>. ActiveRecord makes an object out of a data structure, and adding behaviour beyond data validation makes the model a hybrid data object. <a href="http://railscasts.com/episodes/398-service-objects">Service Objects</a> are abstractions of model behaviour (pun intended).</p>

<p>Now I know what an abstraction is, and I understand that simply extracting methods into interfaces doesn&rsquo;t magically make an abstraction. As Metz says, &ldquo;good design naturally progresses toward small independent objects that rely on abstractions.&rdquo; An object is more than a data structure; it is an idea and it must be applied deliberately.</p>

<!-- resources
http://www.cgore.com/programming/ruby/public-aliases-of-private-methods.lisp
-->


<!-- resources
http://railscasts.com/episodes/398-service-objects
http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#dup vs #clone in Ruby and Rails]]></title>
    <link href="http://www.katieleonard.ca/blog/2015/number-dup-vs-number-clone-in-ruby-and-rails/"/>
    <updated>2015-01-10T00:00:00-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2015/number-dup-vs-number-clone-in-ruby-and-rails</id>
    <content type="html"><![CDATA[<p>I was recently fixing a failing test and discovered that Ruby and Rails implement <code>#clone</code> and <code>#dup</code> in confusing and occasionally opposite ways.</p>

<!--more-->


<h3>In Rails <code>#clone</code> is a less complete copy of an object than <code>#dup</code></h3>

<p>Rails versions have flip-flopped on how to implement <code>#clone</code> and <code>#dup</code>, and there is ambiguity in how Rails defines &ldquo;shallow&rdquo;. In Rails 4.0, <a href="https://github.com/rails/rails/blob/4-0-stable/activerecord/lib/active_record/core.rb#L217-L220"><code>#clone</code> is a shallow copy</a> of an ActiveRecord object. &ldquo;Shallow&rdquo; in this context means that the <code>clone</code> shares attributes with the <code>original</code>:</p>

<blockquote><p>Identical to Ruby&rsquo;s clone method.  This is a &ldquo;shallow&rdquo; copy.  Be warned that your attributes are not copied. That means that modifying attributes of the clone will modify the original, since they will both point to the same attributes hash. If you need a copy of your attributes hash, please use the #dup method.</p></blockquote>

<p>However, <a href="https://github.com/rails/rails/blob/4-0-stable/activerecord/lib/active_record/core.rb#L234-L240"><code>#dup</code> is also described as a shallow copy</a>. &ldquo;Shallow&rdquo; in this context means that while the dup does not share attributes with the original, it does share associations.</p>

<blockquote><p>Duped objects have no id assigned and are treated as new records. Note that this is a &ldquo;shallow&rdquo; copy as it copies the object&rsquo;s attributes only, not its associations. The extent of a &ldquo;deep&rdquo; copy is application specific and is therefore left to the application to implement according to its need.</p></blockquote>

<h4><code>clone</code> vs <code>dup</code> in Rails:</h4>

<p>```bash
pry> original = User.find(3)
  User Load (0.7ms)  SELECT  &ldquo;users&rdquo;.* FROM &ldquo;users&rdquo; WHERE &ldquo;users&rdquo;.&ldquo;id&rdquo; = ? LIMIT 1  [[&ldquo;id&rdquo;, 3]]
=> #<User id: 3, first_name: "katie", last_name: "leonard", email: nil, created_at: "2015-01-10 17:37:00", updated_at: "2015-01-10 17:37:00"></p>

<p>pry> clone_copy = original.clone
=> #<User id: 3, first_name: "katie", last_name: "leonard", email: nil, created_at: "2015-01-10 17:37:00", updated_at: "2015-01-10 17:37:00"></p>

<p>pry> dup_copy = original.dup
=> #<User id: nil, first_name: "katie", last_name: "leonard", email: nil, created_at: nil, updated_at: nil>
```</p>

<p>Note that the <code>clone_copy</code> is an exact copy of the original (same <code>user.id</code>) and the <code>dup_copy</code> is a new record (<code>user.id</code> = nil). Any changes made to the <code>clone_copy</code> will be changed in the <code>original</code>, but any changes to the <code>dup_copy</code> attributes will remain isolated.</p>

<h3>In Ruby <code>#clone</code> is a more complete copy of an object than <code>#dup</code></h3>

<p>With simple classes, <code>clone()</code> and <code>dup()</code> behave identically:</p>

<p>```bash
irb> class User
irb>   attr_accessor :first_name, :last_name, :email
irb>   def initialize(options={})
irb>     @first_name = options[:first_name]
irb>     @last_name  = options[:last_name]
irb>     @email      = options[:email]
irb>   end
irb> end
=> :initialize</p>

<p>irb> original = User.new(first_name: &ldquo;katie&rdquo;, last_name: &ldquo;leonard&rdquo;)
=> #&lt;User:0x007fd7e98e0aa8 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> cloned_copy = original.clone
=> #&lt;User:0x007fd7e98c87c8 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> dup_copy = original.dup
=> #&lt;User:0x007fd7e98b24a0 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> cloned_copy.first_name = &ldquo;foo&rdquo;
=> &ldquo;foo&rdquo;</p>

<p>irb> original.first_name
=> &ldquo;katie&rdquo;</p>

<p>irb> dup_copy.first_name
=> &ldquo;katie&rdquo;</p>

<p>irb> dup_copy.first_name = &ldquo;bar&rdquo;
=> &ldquo;bar&rdquo;</p>

<p>irb> original.first_name
=> &ldquo;katie&rdquo;
<code>``
</code>clone()<code>and</code>dup()` function the same way!</p>

<p><code>clone()</code> from the <a href="http://ruby-doc.org/core-2.1.5/Object.html#method-i-clone">Ruby docs</a>:</p>

<blockquote><p>Produces a shallow copy of obj â€” the instance variables of obj are copied, but not the objects they reference. Copies the frozen and tainted state of obj. See also the discussion under Object#dup.</p></blockquote>

<p><code>dup()</code> from the <a href="http://ruby-doc.org/core-2.1.5/Object.html#method-i-dup">Ruby docs</a> looks suspiciously like the docs for <code>clone()</code>:</p>

<blockquote><p>Produces a shallow copy of obj â€” the instance variables of obj are copied, but not the objects they reference. dup copies the tainted state of obj. This method may have class-specific behavior. If so, that behavior will be documented under the #initialize_copy method of the class.</p></blockquote>

<p>This deserves further clarification:</p>

<blockquote><p>In general, clone and dup may have different semantics in descendant classes. While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendant object to create the new instance. When using dup any modules that the object has been extended with will not be copied.</p></blockquote>

<p>To paraphrase, <code>#dup</code> will act like <code>#clone</code>, but without the original&rsquo;s singleton class (ergo a &ldquo;shallower&rdquo; copy).</p>

<p>```
irb> class User
irb> attr_accessor :first_name, :last_name, :email
irb>   def initialize(options={})
irb>     @first_name = options[:first_name]
irb>     @last_name  = options[:last_name]
irb>     @email      = options[:email]
irb>   end
irb> end
=> :initialize</p>

<p>irb> module Crunchy
irb>   def bacon
irb>     &ldquo;bacon&rdquo;
irb>   end
irb> end
=> :bacon</p>

<p>irb> a = User.new(first_name: &ldquo;katie&rdquo;, last_name: &ldquo;leonard&rdquo;)
=> #&lt;User:0x007fd7e8882490 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> a.extend(Crunchy)
=> #&lt;User:0x007fd7e8882490 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> a.bacon
=> &ldquo;bacon&rdquo;</p>

<p>irb> b = a.clone
=> #&lt;User:0x007fd7e8843060 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> b.bacon
=> &ldquo;bacon&rdquo;</p>

<p>irb> c = a.dup
=> #&lt;User:0x007fd7e98f05c0 @first_name=&ldquo;katie&rdquo;, @last_name=&ldquo;leonard&rdquo;, @email=nil></p>

<p>irb> c.bacon
NoMethodError: undefined method `bacon' for #&lt;User:0x007fd7e98f05c0></p>

<pre><code>    from (irb):101
    from /usr/local/var/rbenv/versions/2.1.5/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<p>```</p>

<p>There are subtle differences between <code>#clone</code> and <code>#dup</code> in Ruby, and less subtle differences in Rails (depending on your version). Take care that the object you want is the object you get.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Lookup in Ruby]]></title>
    <link href="http://www.katieleonard.ca/blog/2014/method-lookup-in-ruby/"/>
    <updated>2014-12-28T00:00:00-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2014/method-lookup-in-ruby</id>
    <content type="html"><![CDATA[<p>I have once more been working my way through Sandi Metz' <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330">Practical Object-oriented Design in Ruby</a> (POODR) for a few weeks, and developed a mental block about method lookup.</p>

<p>In Chapter 6 (Acquiring behaviour through inheritance), she describes how to extract a superclass from a group of related classes that share some behaviour by pulling methods up the inheritance chain instead of driving specializations down. This approach ensures a clean abstraction, leaving no specialized behaviour in the superclass. Where I got stuck was in the call chain that enforces the common interface:</p>

<p>```ruby
class Foo
  def initialize</p>

<pre><code>baz
</code></pre>

<p>  end</p>

<p>  def baz</p>

<pre><code>raise NotImplementedError.new "You can't call #baz here!"
</code></pre>

<p>  end
end</p>

<p>class Bar &lt; Foo
  def initialize</p>

<pre><code>super
</code></pre>

<p>  end</p>

<p>  def baz</p>

<pre><code>puts "Hello, baz"
</code></pre>

<p>  end
end</p>

<blockquote><p>x = Bar.new
&ldquo;Hello, baz&rdquo;
=> #&lt;Bar:0x007fc4f903ab90>
```</p></blockquote>

<p>I could not understand why, the <code>NotImplementedError</code> wasn&rsquo;t raised when a new <code>Bar</code> was created. This is how I imagined the call stack should work:</p>

<ol>
<li><code>Bar.new</code> calls <code>Bar#initialize</code></li>
<li><code>Bar</code> calls <code>super</code> (<code>Foo#initialize</code>)</li>
<li><code>Foo</code> calls <code>baz</code> (<code>Foo#baz</code>)</li>
<li>raises <code>NotImplementedError</code></li>
</ol>


<p>This is how the call stack actually works</p>

<ol>
<li><code>x = Bar.new</code> calls <code>Bar#initialize</code></li>
<li><code>x</code> receives a call to <code>super</code> (<code>Foo#initalize</code>)</li>
<li><code>x</code> receives a call to <code>baz</code> (<code>Bar#baz</code>)</li>
<li>says &ldquo;Hello, baz&rdquo;</li>
</ol>


<p>The call never comes from the context of <code>Foo</code> &mdash; the receiver is always <code>x</code>, the instance of <code>Bar</code>. Classical inheritance dictates that an object can only look to itself or further up the inheritance chain for valid method definitions, not down. <code>x</code> is reaching up to call <code>super</code> but checks itself for an answer to the question <code>#baz</code>. <code>Foo#baz</code> would only ever be called if we made a new <code>Foo</code> directly:</p>

<p>```</p>

<blockquote><p>y = Foo.new
NotImplementedError: You can&rsquo;t call #baz here!</p>

<pre><code>    from (irb):7:in `baz'
    from (irb):3:in `initialize'
    from (irb):27:in `new'
    from (irb):27
    from /usr/local/var/rbenv/versions/2.1.5/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<p>```</p></blockquote>

<h3>How ruby resolves a message (classical inheritance)</h3>

<p>The search for a method begins in the class of the receiving object &mdash; in the example above, Bar is always the receiving object. If the class does not implement the message, the search proceeds up the superclass chain. If none of the superclasses contain the method definition, ruby makes a second attempt to resolve the message by sending <code>method_missing(:method_name)</code> to the original object. The search restarts from the bottom, but this time for a <code>method_missing</code> handler rather than <code>:method_name</code>.</p>

<p>Occasionally refreshing the ruby basics is super-rewarding.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Execution]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/ruby-execution/"/>
    <updated>2013-09-10T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/ruby-execution</id>
    <content type="html"><![CDATA[<p>I have started including an executable in my project setup. Many of the code challenges I have been practicing lately have included file I/O, and while TDD and code exercising with RSpec is still my main process, developing a stand-alone fully-functional project requires something more.</p>

<!--more-->


<h3>Blocks Code Challenge</h3>

<p>I found the blocks code challenge on the <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=37">UVa code competition website</a>. To sum up, you have to write a program that will parse and carry out a series of commands for stacking blocks.</p>

<ol>
<li>move a onto b</li>
<li>move a over b</li>
<li>pile a onto b</li>
<li>pile a over b</li>
<li>quit</li>
</ol>


<p>The commands will be provided in an input file, and an output is specified. Fun problem, right? So, I start my project folder using my <a href="http://www.katieleonard.ca/automation/2013/09/08/thor-sets-up-a-project/">thor task</a>, and work awhile adding logic and tests and data as appropriate. My file tree finishes like this:
<div>
  <pre><code class='bash'>blocks
â”œâ”€â”€ data
â”‚Â Â  â”œâ”€â”€ input.txt
â”‚Â Â  â””â”€â”€ output.txt
â”œâ”€â”€ lib
â”‚Â Â  â””â”€â”€ blocks.rb
â”œâ”€â”€ spec
â”‚Â Â  â”œâ”€â”€ blocks_spec.rb
â”‚Â Â  â””â”€â”€ spec_helper.rb
â”œâ”€â”€ Gemfile
â””â”€â”€ README.md</code></pre>
</div>
</p>

<p>So, in order to use my script, I would have to call it from the command line:
<div>
  <pre><code class='bash'>$ ruby lib/blocks.rb data/input.txt&lt;/p&gt;

&lt;h1&gt;=&gt; or&lt;/h1&gt;

&lt;p&gt;$ data/input.txt | ruby lib/blocks.rb</code></pre>
</div>
</p>

<p>This is an extremely verbose way to deliver a final product, and I would much rather call $ blocks &lt;file_input&gt;. It turns out that making an executable is easy and elegant, just like everything else in ruby. You just have to declare the ruby environment, include a few notes on usage, load the file tree, and call the class:
<div>
  <pre><code class='ruby'>&lt;/p&gt;

&lt;h1&gt;!/usr/bin/env ruby&lt;/h1&gt;

&lt;h1&gt;blocks&lt;/h1&gt;

&lt;h1&gt;10-Sep-2013&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Usage:&lt;/h1&gt;

&lt;h1&gt;./blocks data/input.txt&lt;/h1&gt;

&lt;p&gt;#
$LOAD_PATH.unshift(File.join(File.dirname(&lt;strong&gt;FILE&lt;/strong&gt;), &amp;lsquo;lib&amp;rsquo;))
require &amp;lsquo;blocks&amp;rsquo;
Blocks.new.process_input</code></pre>
</div>
</p>

<p>Placing this code in a non-extension file, like &lsquo;blocks&rsquo;, in the main directory, I can make it an executable by changing the file permissions:
<div>
  <pre><code class='bash'>$ chmod +x ./blocks</code></pre>
</div>
</p>

<p>And I can call it like any other executable:
<div>
  <pre><code class='bash'>$ ./blocks data/input.txt</code></pre>
</div>
</p>

<p>I liked this solution so much, I added it to my thor project setup! Oh, and if you are interested in seeing my solution for the blocks problem, checkout my <a href="https://github.com/keighty/datastructures/tree/master/ruby/blocks">github repo</a></p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thor Sets Up a Project]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/thor-sets-up-a-project/"/>
    <updated>2013-09-08T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/thor-sets-up-a-project</id>
    <content type="html"><![CDATA[<p>A few weeks ago I posted about <a href="http://www.katieleonard.ca/automation/2013/08/30/hammer-out-tasks-with-thor/">using Thor to generate system-wide notes files with a standard format</a>. Since then, I have been doing a lot of smaller code challenges, and I wanted to set up a Thor task for generating a standard project file tree.</p>

<!--more-->


<p>My Goal Tree:
<div>
  <pre><code class='bash'>project_name
â”œâ”€â”€ lib
â”‚Â Â  â””â”€â”€ project_name.rb
â”œâ”€â”€ spec
â”‚Â Â  â”œâ”€â”€ project_name_spec.rb
â”‚Â Â  â””â”€â”€ spec_helper.rb
â”œâ”€â”€ Gemfile
â””â”€â”€ README.md</code></pre>
</div>
</p>

<p>I always begin with these files and this organization. A Gemfile and README are essential for setting up the environment and explaining the gist of the project. I am most comfortable with RSpec, and to get into the practice of TDD, setting up a testing environment right away is non-negotiable. All of these standard files contain some automatic content as well:</p>

<h5>spec_helper.rb loads the library</h5>

<p><div>
  <pre><code class='ruby'>$LOAD_PATH.unshift(File.join(File.dirname(&lt;strong&gt;FILE&lt;/strong&gt;), &amp;lsquo;..&amp;rsquo;, &amp;lsquo;lib&amp;rsquo;))
require &amp;lsquo;rspec&amp;rsquo;
require &amp;lsquo;project_name&amp;rsquo;</code></pre>
</div>
</p>

<h5>project_name_spec.rb sets up the first test</h5>

<p><div>
  <pre><code class='ruby'>require &amp;lsquo;spec_helper&amp;rsquo;&lt;/p&gt;

&lt;p&gt;describe ProjectName do
  before (:each) {  }
  subject {  }&lt;/p&gt;

&lt;p&gt;  it &amp;ldquo;should pass&amp;rdquo;
end</code></pre>
</div>
</p>

<h5>Gemfile specifies the right gems for setting up the project</h5>

<p><div>
  <pre><code class='ruby'>ruby &amp;lsquo;2.0.0&amp;rsquo;
gem &amp;lsquo;rspec&amp;rsquo;</code></pre>
</div>
</p>

<p>There are other files that could have auto-generated content as well, like a Rakefile, or a config.ru, but this is a good start.</p>

<h4>Create a Thor task (rb_project.thor):</h4>

<p><div>
  <pre><code class='ruby'>&lt;/p&gt;

&lt;h1&gt;!/usr/bin/env ruby&lt;/h1&gt;

&lt;p&gt;require &amp;ldquo;rubygems&amp;rdquo;
require &amp;ldquo;thor&amp;rdquo;&lt;/p&gt;

&lt;p&gt;class RbProject &amp;lt; Thor
  desc &amp;ldquo;init&amp;rdquo;, &amp;ldquo;creates a ruby project with rspec&amp;rdquo;&lt;/p&gt;

&lt;p&gt;  def init(title=&amp;ldquo;new_project&amp;rdquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dir.mkdir(title)
Dir.chdir(title)
Dir.mkdir(&quot;spec&quot;)
Dir.mkdir(&quot;lib&quot;)
filename = &quot;#{title}&quot;

open(File.new(&quot;README.md&quot;, &quot;w&quot;), &quot;w&quot;) do |note|
  note.puts &quot;# #{title}&quot;
end

open(File.new(&quot;Gemfile&quot;, &quot;w&quot;), &quot;w&quot;) do |my_gem|
  my_gem.puts &quot;ruby &#39;2.0.0&#39;&quot;
  my_gem.puts &quot;gem &#39;rspec&#39;&quot;
end

open(File.new(&quot;spec/spec_helper.rb&quot;, &quot;w&quot;), &quot;w&quot;) do |spec|
  spec.puts &quot;$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), &#39;..&#39;, &#39;lib&#39;))&quot;
  spec.puts &quot;require &#39;rspec&#39;&quot;
  spec.puts &quot;require &#39;#{filename}&#39;&quot;
end

open(File.new(&quot;spec/#{filename}_spec.rb&quot;, &quot;w&quot;), &quot;w&quot;) do |spec|
  spec.puts &quot;require &#39;spec_helper&#39;&quot;
  spec.puts &quot;&quot;
  spec.puts &quot;describe #{camelize(filename)} do&quot;
  spec.puts &quot;  before (:each) {  }&quot;
  spec.puts &quot;  xit &#39;should pass&#39;&quot;
  spec.puts &quot;end&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  end&lt;/p&gt;

&lt;p&gt;  private&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def camelize(snake)
  title = snake.split(&#39;_&#39;).each do |word|
    word.capitalize!
  end
  title.join(&#39;&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end</code></pre>
</div>
</p>

<p>I created a private method camelize in order to change the snake_case project name into a CamelCase class name.</p>

<p>As before, I install my thor task system wide:
<div>
  <pre><code class='bash'>$ thor install rb_project.thor</code></pre>
</div>
</p>

<p>And now my project generation task can be run from any directory, anywhere on my system:
<div>
  <pre><code class='bash'>$ thor list&lt;/p&gt;

&lt;h2&gt;note&lt;/h2&gt;

&lt;p&gt;thor note:create  # creates a notes file in markdown&lt;/p&gt;

&lt;h2&gt;rb_project&lt;/h2&gt;

&lt;p&gt;thor rb_project:init  # creates a ruby project with rspec&lt;/p&gt;

&lt;p&gt;$ thor rb_project:init test_project
$ tree test_project/
test_project/
â”œâ”€â”€ lib
â”‚Â Â  â””â”€â”€ test_project.rb
â”œâ”€â”€ spec
â”‚Â Â  â”œâ”€â”€ spec_helper.rb
â”‚Â Â  â””â”€â”€ test_project_spec.rb
â”œâ”€â”€ Gemfile
â”œâ”€â”€ README.md&lt;/p&gt;

&lt;p&gt;2 directories, 6 files</code></pre>
</div>
</p>

<p>Awesome.</p>

<p><div>
  <pre><code class='bash'></code></pre>
</div>

<div>
  <pre><code class='bash'></code></pre>
</div>
</p>
]]></content>
  </entry>
  
</feed>
