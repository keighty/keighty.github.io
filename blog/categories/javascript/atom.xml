<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2016-10-12T13:02:52-07:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    <email><![CDATA[keighty.leonard@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Callbacks and the Event Loop]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/clarified-callbacks/"/>
    <updated>2016-10-12T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/clarified-callbacks</id>
    <content type="html"><![CDATA[<p>When I started writing javascript in earnest a couple of years ago, I was stuck in a very procedural way of thinking &mdash; all of my functions executed synchronously. If you replaced <code>function</code> with <code>def</code> and removed all <code>var</code> keywords, you would be reading Ruby (true story: yesterday I was debugging an issue with a React module and put in a <code>binding.pry</code> instead of <code>debugger</code> :facepalm: Old habits die hard).</p>

<p>Last year, I joined a team that writes javascript in the Node.js style, using callbacks for flow control. While I became familiar with the pattern pretty quickly, the whys and wherefores were missing from my understanding. Today I am filling in the gaps by reading <a href="https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1785885588/ref=sr_1_1/161-7210115-5247461?ie=UTF8&amp;qid=1476284148&amp;sr=8-1&amp;keywords=node.js+design+patterns">Node.js Design Patterns</a> by Mario Casciaro and Luciano Mammino.<!--more--></p>

<h3>The Event Loop</h3>

<p>The first step to understanding asynchronous javascript is to understand the event loop. It is a single thread that processes one message at a time, as they appear in the FIFO event queue.</p>

<p><img src="/images/161012-callbacks/event-loop.png">
<em>image credit: Mario Casciaro and Luciano Mammino from Node.js Design Patterns. Colour notations are mine.</em></p>

<ol>
<li>An I/O request is sent to the event demultiplexer.</li>
<li>The event demultiplexer queues the I/O instructions along with the context and a callback function that contains the instructions for what do to with the result once it is received.</li>
<li>When the I/O order is filled, the event demultiplexer pops an event on to the event queue, with the filled I/O request, and the callback handler.</li>
<li>The event loop pulls the event off of the event queue and applies the result to the callback function.</li>
<li>The event loop either sends the result of the callback operation to the application, or generates more I/O work for the event demultiplexer.</li>
</ol>


<p>When I check my email in the morning, I go through a similar process:</p>

<ul>
<li>My inbox is the event demultiplexer, where requests for resources are made.</li>
<li>I (as the event loop) process emails from in the queue from oldest to newest, and I only process one at at time.</li>
<li>For each message I read the context and perform one of two actions (callback):

<ul>
<li>Process the message and return to the queue to pick up another message.</li>
<li>Add a new action to my todo list event queue along with the a reminder to attach the result of the new action to the email when I respond (callback).</li>
</ul>
</li>
</ul>


<p>When I am finished with my email inbox I start on my todo list, performing the actions required and responding to the email. Sometimes the action will generate additional actions, which I append to the end of my todo list. While the idea of an infinite todo list is a little disheartening to a human, this is how the V8 javascript engine was designed: it performs the work with maximum efficiency, and can do so with only a single thread.</p>

<h3>The difference between synchronous and asynchronous javascript</h3>

<p>Synchronous javascript can be easily identified by the use of a <code>return</code> statement, which returns control back to the caller.</p>

<p>```javascript
function introduction (firstName, lastName) {
  return &lsquo;Hello, my name is &rsquo; + firstName + &lsquo; &rsquo; + lastName
}</p>

<p>introduction(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;)
// &ldquo;hello! my name is Keighty Leonard&rdquo;
```</p>

<p>Asynchronous javascript uses a &lsquo;continuous passing pattern&rsquo;, where the result of a function is passed to a handler for further processing.</p>

<p>```javascript
function createEmailAddress (firstName, lastName, callback) {
  // create asynchronous call
  console.log(&lsquo;before the async&rsquo;)
  setTimeout(function () {</p>

<pre><code>// do some work
var email = firstName.toLowerCase() + '.' + lastName.toLowerCase() + '@example.com'
console.log('during the async')
// pass the result of the work to the callback
callback(email)
</code></pre>

<p>  }, 2000)
  console.log(&lsquo;after the async&rsquo;)
}</p>

<p>var cb = function (result) {
  console.log(result)
}</p>

<p>createEmailAddress(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;, cb)</p>

<p>// > before the async
// > after the async
// > during the async
// > <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#107;&#x65;&#x69;&#x67;&#104;&#116;&#121;&#x2e;&#x6c;&#101;&#111;&#x6e;&#97;&#114;&#x64;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x6b;&#x65;&#x69;&#x67;&#104;&#116;&#121;&#x2e;&#108;&#101;&#111;&#110;&#97;&#114;&#100;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>
```</p>

<p><code>createEmailAddress</code> is called. When execution reaches the setTimeout function, and the 2000ms have elapsed, the callback passed to setTimeout is placed in the event queue, awaiting its turn for execution. The thread is release and does not have to wait for the setTimeout period to elapse before continuing execution &mdash; it continues with the second console statement (&lsquo;after the async&rsquo;). When the setTimeout callback is finally processed, the <code>firstName</code> and <code>lastName</code> variables are still accessible because they exist in the function closure.</p>

<p>Javascript has many features that make the continuous passing pattern easy:</p>

<ul>
<li>Closures allow you to access the environment on which a function was created, no matter when the callback is invoked.</li>
<li>Functions are first class data types, meaning they can be assigned to variables, passed as parameters, and stored in data structures.</li>
</ul>


<hr />

<p>More on the event loop and event-emitter observer pattern to come!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Importing and Exporting: Modular React]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react/"/>
    <updated>2016-08-18T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react</id>
    <content type="html"><![CDATA[<p>While working on rewriting my side-project (VirtualPlaybill) in React, I got hung up on a very basic plumbing concept: named exports. <!--more--></p>

<p>With ES5 you can export in three ways and import in one:
```javascript
// EXPORT STYLE 1
module.exports = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
};</p>

<p>// EXPORT STYLE 2
exports.crunchy = function() { console.log(&lsquo;CRUNCHY!&rsquo;) }
exports.bacon = function() { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// EXPORT STYLE 3 (and my personal favourite)
var breakfast = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
}
module.exports = breakfast
```</p>

<p>An export is a meaningful bundle of code. Importing takes a single form, providing a handle to the exported bundle:</p>

<p>```javascript
// IMPORT
var breakfast = require(&lsquo;breakfast.js&rsquo;)</p>

<p>breakfast.crunchy() // CRUNCHY!
breakfast.bacon() // BACON!
```</p>

<p>In ES6 there is a lot more flexibility: exports can be named and imports can take many forms.</p>

<h4>Named exports</h4>

<p>Importing a named export allows you to grab only the functions you need from a module, leaving the rest behind. Use curly braces to import a named export:
```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY NAME
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import { crunchy } from &lsquo;./test&rsquo;
crunchy() // CRUNCHY!
bacon() // Uncaught ReferenceError: bacon is not defined(…)
```</p>

<h4>Default exports</h4>

<p>In addition to named exports, you can specify one <code>default</code> export per file. Simply importing that file provides a reference to the default export:</p>

<p>```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
default export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY DEFAULT
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import myFunc from &lsquo;./test&rsquo;
myFunc() // BACON!
```</p>

<p>You can also import both default and named exports at the same time:
<code>javascript
import myFunc, { crunchy } from './test'
crunchy() // CRUNCHY!
myFunc() // BACON!
</code></p>

<p>For even more import options, checkout the section on imports from the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">MDN docs</a>:</p>

<p><code>javascript
import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as name from "module-name";
import "module-name"
</code></p>

<p>name</p>

<blockquote><p>Name of the object that will receive the imported values.</p></blockquote>

<p>member, memberN</p>

<blockquote><p>Name of the exported members to be imported.</p></blockquote>

<p>defaultMember</p>

<blockquote><p>Name of the exported default to be imported.</p></blockquote>

<p>alias, aliasN</p>

<blockquote><p>Name of the object that will receive the imported property</p></blockquote>

<p>module-name</p>

<blockquote><p>The name of the module to import. This is a file name.</p></blockquote>

<h4>What you CAN&rsquo;T do&hellip;</h4>

<p>&hellip; is use ES5 syntax and expect the import to know what you mean:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>export default MyComponent</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // undefined
```</p>

<p>I was trying to write ES5 in ES6! Without an explicit <code>export</code> in front of the class declaration, my default had no idea what I intended to export, so it did nothing. Adding <code>export</code> to the class definition, or even moving the whole <code>export default</code> to the class declaration does the job:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
default export class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // function MyComponent() {&hellip;}
```</p>

<p>Thanks to <a href="http://stackoverflow.com/a/31853887">this stackoverflow answer</a> for pointing me in the right direction, and <a href="http://exploringjs.com/es6/ch_modules.html">exploringjs</a> for even greater detail!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nested Routes With Expressjs]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/nested-routes-with-expressjs/"/>
    <updated>2016-04-12T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/nested-routes-with-expressjs</id>
    <content type="html"><![CDATA[<p>Whenever I need to build a quick web application I turn to <a href="http://expressjs.com/">ExpressJS</a>. It is a fast, minimal, easy to configure web server that puts the <strong>E</strong> in <a href="http://mean.io/#!/">MEAN</a>). I wanted to build a REST API for a hobby app and found that the docs for how to nest routes are relatively few (see <a href="http://codetunnel.io/an-intuitive-way-to-organize-your-expressjs-routes/">blog</a>, <a href="http://stackoverflow.com/a/25305272/1279340">stackoverflow answer</a>). Combining these two resources, I learned a simple method for keeping your routes separate while creating a nested routing structure. <!--more--></p>

<h2>The Plan</h2>

<p>I want to create routes that look like these:</p>

<ul>
<li><code>/foo</code></li>
<li><code>/foo/bar</code></li>
<li><code>/foo/42</code></li>
<li><code>/foo/42/baz</code></li>
<li><code>/foo/42/baz/123</code></li>
</ul>


<p>Using the <a href="http://expressjs.com/en/starter/generator.html">express-generator</a> and a few simple commands, you can get your server up and running fast:</p>

<p><code>
$ npm install express-generator -g
$ express myapp
$ cd myapp
$ npm install
$ npm start
</code></p>

<p>You will end up with a working directory that looks like this:</p>

<p>```
├── app.js
├── bin
│   └── www
├── node_modules
│   ├── &hellip;
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views</p>

<pre><code>├── error.jade
├── index.jade
└── layout.jade
</code></pre>

<p>```</p>

<p>Go ahead and delete the <code>/routes/users.js</code> file and the following lines from <code>app.js</code></p>

<p><code>javascript app.js
...
var users = require('./routes/users');
...
app.use('/users', users);
</code></p>

<p>Then create a new routes file named <code>/routes/foo.js</code> and and require it from your app server.
<code>javascript app.js
...
app.use('/foo', require('./routes/foo'));
...
</code></p>

<h2>How to <code>GET /foo</code></h2>

<p>Inside <code>/routes/foo.js</code>, you need to require the router module from ExpressJS, define a route on it, and export it back out.</p>

<p>```javascript /routes/foo.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()</p>

<p>// GET /foo
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for foo&rsquo;)
})</p>

<p>module.exports = router
```</p>

<p>Everytime you change a route, you need to restart your server. Nevigating to <a href="http://localhost:3000/foo">localhost:3000/foo</a> should display the message:</p>

<p><img src="/images/160412-nested-routes/foo.png"></p>

<h2>How to <code>GET /foo/bar</code></h2>

<p>Create simple nested routes by requiring the child route file from the parent route file.</p>

<p>```javascript /routes/foo.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()
var bar = require(&lsquo;./bar&rsquo;)</p>

<p>// GET /foo
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for foo&rsquo;)
});</p>

<p>// GET /foo/bar
router.use(&lsquo;/bar&rsquo;, bar) // tell the router to use bar.js for child routes</p>

<p>module.exports = router
```</p>

<p>Create a new routes file named <code>/routes/bar.js</code> and define a root route the same way you did for <code>/routes/foo.js</code>:</p>

<p>```javascript /routes/bar.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()</p>

<p>// GET /foo/bar
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for bar&rsquo;)
});</p>

<p>module.exports = router
```</p>

<p>Bounce your server again and navigate to <a href="http://localhost:3000/foo/bar">localhost:3000/foo/bar</a></p>

<p><img src="/images/160412-nested-routes/foobar.png"></p>

<h2>How to <code>GET /foo/42</code></h2>

<p>Expecting a parameter? No problem! access URL params directly from the request object: <code>req.params.nameOfParam</code>:</p>

<p>```javascript /routes/foo.js
&hellip;
// GET /foo/42
router.get(&lsquo;/:number&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is foo #&rsquo; + req.params.number)
})</p>

<p>module.exports = router
```
Navigate to <a href="http://localhost:3000/foo/42">localhost:3000/foo/42</a> to see the result.</p>

<p><img src="/images/160412-nested-routes/fooNumber.png"></p>

<h2>How to <code>GET /foo/42/baz</code></h2>

<p>Getting a child route from a parameterized parent is where I was getting confused. It turns out that you need to configure the router a little differently when you are passing params through.</p>

<p>```javascript /routes/foo.js
&hellip;
var baz = require(&lsquo;./baz&rsquo;)</p>

<p>&hellip;
// GET /foo/42/baz
router.use(&lsquo;/:number/baz&rsquo;, baz)</p>

<p>module.exports = router
```</p>

<p>You need to pass an options object to <code>express.Router</code> to merge the params from any parent route:</p>

<p>```javascript /routes/baz.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router({mergeParams: true}) // don&rsquo;t forget the parent params!</p>

<p>// GET /foo/42/baz
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  // the param name is from the parent as well
  res.send(&lsquo;this is the baz for foo#&rsquo; + req.params.number);
})</p>

<p>module.exports = router
```</p>

<p>Navigate to <a href="http://localhost:3000/foo/42/baz">localhost:3000/foo/42/baz</a> to enjoy your success.</p>

<p><img src="/images/160412-nested-routes/fooNumberBaz.png"></p>

<h2>How to <code>GET /foo/42/baz/123</code></h2>

<p>Parameterizing a child route is the same process as for the parent route:</p>

<p>```javascript /routes/baz.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router({mergeParams: true})</p>

<p>// GET /foo/42/baz
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the baz for foo#&rsquo; + req.params.number);
})</p>

<p>// GET /foo/42/baz/123
router.get(&lsquo;/:id&rsquo;, function (req, res, next) {
  res.send(&lsquo;baz #&rsquo; + req.params.id + ‘ for foo #’ + req.params.number)
})</p>

<p>module.exports = router
```</p>

<p>Navigate to <a href="http://localhost:3000/foo/42/baz/123">localhost:3000/foo/42/baz/123</a> to enjoy your success.</p>

<p><img src="/images/160412-nested-routes/fooNumberBazNumber.png"></p>

<p>TADA! a model of nested routes that you can apply to any application.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Preflight Check With CORS]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/preflight-check-with-cors/"/>
    <updated>2016-03-29T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/preflight-check-with-cors</id>
    <content type="html"><![CDATA[<p>Modern web applications can draw resources from anywhere on the web. Fonts, JavaScript libraries, images, and other data can be fetched from CDNs, Amazon, IMDB, or anywhere else that provides a public API. Early browsers restricted web applications to same-origin requests, which prevented the sharing of resources between applications, but also ensured that data from one application could not be tampered with by another. The thinkers at the W3C came up with a means of communicating safe cross-origin requests that would allow even destructive remote actions to be performed, as long as the server consented to receive the request. Enter CORS, and preflighting.</p>

<!--more-->


<h3>What is CORS?</h3>

<p>Cross-Origin Resource Sharing occurs when JavaScript on a web page requests data from (or sends data to) a location on a different host. Any website that embeds a video from YouTube, uses a custom font, or posts to social media on your behalf, is making a CORS request. CORS is a <a href="https://www.w3.org/TR/cors/">set of web standards</a> developed to enable safe cross-domain communication.</p>

<h3>What is preflighting?</h3>

<p>CORS functions through the specification of new HTTP headers that allow servers to describe the origin and nature of the request. For each outgoing request to a different domain, the browser will look at the headers to determine if the request that looks like it will affect data on the receiving server. Any simple request that uses one of the common HTTP verbs and a basic Content-Type are allowed to pass without further comment. But if the request has different header values, the browser checks with the server first to make sure the request is expected. This is called a pre-flight check.</p>

<h3>What does a simple CORS request look like?</h3>

<p>For simple requests (no pre-flight check), the method must be one of:</p>

<pre><code>- GET
- HEAD
- POST
</code></pre>

<p>The only extra headers allowed are:</p>

<pre><code>- Accept
- Accept-Language
- Content-Language
- Content-Type
</code></pre>

<p>For the Content-Type header, the only allowed values are:</p>

<pre><code>- application/x-www-form-urlencoded
- multipart/form-data
- text/plain
</code></pre>

<p>XMLHttpRequests (aka XHRs or ajax) use CORS to mitigate the risks of pulling or pushing sensitive data across domains. For example:</p>

<p><code>javascript
var body = 'very safe, ordinary text content'
var url = 'http://api.example.com'
var request = new XMLHttpRequest()
request.open('POST', url, true)
request.setRequestHeader('Content-Type', 'text/plain')
request.send()
</code></p>

<p><img src="/images/160329-preflight-cors/cors-without-preflight.png"></p>

<p>The browser checks out the request, sees that it is unlikely to have any negative consequences, and passes it along to the requested endpoint. In the Network tab, simple CORS requests will appear by themselves:</p>

<p><img src="/images/160329-preflight-cors/one-request.png"></p>

<h3>What does a pre-flight CORS request look like?</h3>

<p>For non-simple requests, the method could be any of the HTTP verbs along with any other combination of headers. For example:</p>

<p><code>javascript
var body = 'possibly unstable or malicious content'
var url = 'http://api.example.com'
var request = new XMLHttpRequest()
request.open('POST', url, true)
request.setRequestHeader('Content-Type', 'application/json')
request.send()
</code></p>

<p>In this request I am trying to POST a JSON object to an API endpoint, which could potentially have destructive consequences for data on the other side of the endpoint. When the browser inspects the headers of this request it gets suspicious, and fires off a preliminary request to the endpoint with the meta data from the request:</p>

<p><img src="/images/160329-preflight-cors/cors-with-preflight.png"></p>

<p>The server at the endpoint responds to the pre-flight request with a list of authorized headers, including acceptable request origins, content, and actions.</p>

<p>Ignoring for a moment that the requests fail (because api.example.com does not exist), the non-simple CORS request produces two requests instead of one:
<img src="/images/160329-preflight-cors/two-requests.png"></p>

<p>The result of the pre-flight OPTIONS request will determine if the second is ever sent on to the endpoint. This is how browsers keep your application data secure from malicious or unintended changes.</p>

<h3>Why OPTIONS, and not POST?</h3>

<p>I found <a href="http://stackoverflow.com/a/16945321">this great answer</a> on stackoverflow that explains why the creators of CORS made a new request type, <code>OPTIONS</code>. Before the CORS standards were introduced, neither browsers nor servers knew how to handle cross-domain requests. Browsers would throw an error, but servers would process the request without concern. Inventing a new method type that CORS-enabled browsers AND CORS-aware servers could handshake with ensures that both sides are sensible to the meaning of the pre-flight request.</p>

<h4>RESOURCES</h4>

<ul>
<li>Learn more about the web standards at <a href="https://www.w3.org/TR/cors/">W3C</a></li>
<li>Find out more about how CORS is <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests:">implemented at Mozilla</a></li>
<li>Find out what web browsers support CORS at <a href="http://caniuse.com/#search=CORS">caniuse.com</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript Object Property Meta Properties]]></title>
    <link href="http://www.katieleonard.ca/blog/2015/javascript-object-property-meta-properties/"/>
    <updated>2015-11-07T00:00:00-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2015/javascript-object-property-meta-properties</id>
    <content type="html"><![CDATA[<p>JavaScript Objects are complex types, and even defined properties have a control panel of their own. You can view the content of the control panel using <code>Object.getOwnPropertyDescriptor()</code>, and flip their switches using <code>Object.defineProperty()</code>. <!--more--></p>

<blockquote><p>Note: These property descriptors are for <code>own properties</code> &mdash; that is, properties that are directly defined on an object, not those that come along for the ride on the object&rsquo;s prototype chain.</p></blockquote>

<h3>The property descriptor holds meta data</h3>

<p>```</p>

<blockquote><p>var me = {
  name: &ldquo;Katie&rdquo;
}</p>

<p>Object.getOwnPropertyDescriptor( me, &ldquo;name&rdquo; )
{
  value: &ldquo;Katie&rdquo;, // the value associated with the property
  writable: true,   // true if the value of the property can be changed
  enumerable: true, // true if the property shows up during enumeration of the properties
  configurable: true // true if any of these meta properties can be changed
}
```</p></blockquote>

<h3>Change the property value</h3>

<p>```
Object.defineProperty( me, &ldquo;name&rdquo;, {
  value: &ldquo;keighty&rdquo;
})</p>

<p>me.name // &ldquo;keighty&rdquo;
```</p>

<h3>Make the property read only</h3>

<p>```
Object.defineProperty(me, &ldquo;name&rdquo;, {
  writable: false
})</p>

<p>me.name = &ldquo;k80&rdquo;
me.name  //&ldquo;keighty&rdquo; &mdash; actual value of me.name did not change
```</p>

<h3>Make the property hidden from for-loops (or any enumeration)</h3>

<p>```
me.hobbies = [&ldquo;bridge&rdquo;, &ldquo;curling&rdquo;, &ldquo;tap dancing&rdquo;]
me // Object {hobbies: Array[3], name: &ldquo;keighty&rdquo;}</p>

<p>for(fact in me) {
 console.log(fact)
}
// All the properties defined on me are written to the console:
// name
// hobbies</p>

<p>Object.defineProperty(me, &ldquo;name&rdquo;, {
 enumerable: false
})</p>

<p>for(fact in me) {
 console.log(fact)
}
// Actually.. only enumerable properties are written to the console:
// hobbies
```</p>

<h3>Freeze the property</h3>

<p>```
Object.defineProperty(me, &ldquo;name&rdquo;, {
 configurable: false
})</p>

<p>Object.getOwnPropertyDescriptor(me, &ldquo;name&rdquo;)
// { value: &ldquo;keighty&rdquo;,
//   writable: false,
//   enumerable: false,
//   configurable: false }</p>

<p>Object.defineProperty(me, &ldquo;name&rdquo;, {
 writable: true
})</p>

<p>Uncaught TypeError: Cannot redefine property: name(…)
```</p>

<p>From <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.10">the docs</a>: &ldquo;The Property Descriptor type is used to explain the manipulation and reification of named property attributes. Use Object.defineProperty for fine-grained control over the visibility and mutability of your object&rsquo;s properties.</p>
]]></content>
  </entry>
  
</feed>
