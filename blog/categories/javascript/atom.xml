<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2016-10-15T17:28:18-07:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    <email><![CDATA[keighty.leonard@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Service Workers]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/service-workers/"/>
    <updated>2016-10-15T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/service-workers</id>
    <content type="html"><![CDATA[<p>A service worker is a script that sits between a web page and the network, acting as a proxy for network requests: if the network is available, the request is passed on to the target url; if the network is not available, the service worker will handle the request itself by checking cached responses or or queuing the request for synchronization once the network is available. Service workers are bridging the gap between native mobile applications and traditional web applications that require a network connection to function. Sometimes called progressive web apps, these applications enable a seamless offline experience when the user is not connected to a network.</p>

<!--more-->


<p>Service workers can be used for data synchronization in the background, but data fetching and sync-ing are only one of the ways we can leverage this API. We can:</p>

<ul>
<li>use background resources to perform client-side compilation of assets  (useful for web development)</li>
<li>pre-fetch data that the user is likely going to need in the near future (think photo albums or playlists)</li>
<li>share large data sets between multiple pages</li>
<li>notify mobile users of updates via push notifications</li>
</ul>


<p>For example, <a href="https://www.washingtonpost.com/">The Washington Post</a> uses service workers to send push notifications of breaking news content to users of their web application on android.</p>

<h2>How do they work?</h2>

<p>Service workers rely on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise API</a> &mdash; a Promise is a proxy for &ldquo;a value that may be  available now, or in the future, or never.&rdquo; They also use the event emitter pattern, where listeners are registered to handle specific events, such as <code>fetch</code> requests.</p>

<p>To employ a service worker you must first register a script with the service worker API: <code>navigator.serviceWorker.register('./sw.js')</code>. Checkout the following example (<a href="https://gist.github.com/keighty/ec1a37a0f6475d7cdf2db64b01eff445.js">get the gist</a>):</p>

<p>```html</p>

<!-- index.html references the javascript application -->


<p><html>
  <body></p>

<pre><code>&lt;h1&gt;Service worker test app&lt;/h1&gt;
&lt;script src="./app.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
<code>
</code>javascript
// app.js
.register(&lsquo;sw.js&rsquo;) // register a worker script with the service
navigator.serviceWorker
  .then(function(reg) {</p>

<pre><code>// do the following if registration is successful
if(reg.installing) {
  // first visit or fresh reload of the worker
  console.log('Service worker installing on registration.');
} else if(reg.waiting) {
  // a worker may be installed but waiting for another worker to stop
  console.log('Service worker already installed on registration.');
} else if(reg.active) {
  // pages from the same origin may share a service worker
  console.log('Service worker already active on registration.');
}
</code></pre>

<p>  }).catch(function(error) {</p>

<pre><code>// if registration is unsuccessful, tell us why
console.log('Registration failed with ' + error);
</code></pre>

<p>  });
<code>
</code>javascript
// sw.js
console.log(&lsquo;inside registration script&rsquo;)</p>

<p>this.addEventListener(&lsquo;install&rsquo;, function(event) {
  console.log(&lsquo;Service worker installed.&rsquo;)
});</p>

<p>this.addEventListener(&lsquo;activate&rsquo;, function (event) {
  console.log(&lsquo;Service worker activated.&rsquo;)
})
```</p>

<p>Service workers can be registered with a specific origin and path to watch. Since they run in a background thread with a context separate from the application javascript, service workers have no DOM access. So don&rsquo;t try to perform synchronous work (like accessing LocalStorage) or update the DOM from a service worker.</p>

<p>Running this example code sends some output to the console:
<img src="/images/161015-service-workers/service-worker-demo1.png"></p>

<h4>NOTE: A single service worker can control many pages (so be careful with global variables).</h4>

<p><img src="/images/161015-service-workers/service-worker-demo2.png"></p>

<h2>Developing with service workers</h2>

<p>Service workers can only function in a secure context, which means that you can only register a service worker from a web application that is served over <code>https</code>. One option is to use <a href="https://pages.github.com/">GitHub pages</a> to deploy your application, as these pages are generally served over <code>https</code>. Another option is to use a local web server (<code>localhost</code> is considered semi-secure).</p>

<p>I use <a href="https://www.browsersync.io/">Browser-sync</a>, a super light-weight easy to start web server. In my project directory, I start the browser-sync server and set it to watch my javascript files:</p>

<p>```bash
$ npm install -g browser-sync
$ browser-sync start &mdash;server &mdash;files *.js
[BS] Access URLs:</p>

<hr />

<pre><code>   Local: http://localhost:3000
External: http://10.0.0.8:3000
</code></pre>

<hr />

<pre><code>      UI: http://localhost:3001
</code></pre>

<p> UI External: <a href="http://10.0.0.8:3001">http://10.0.0.8:3001</a></p>

<hr />

<p>[BS] Serving files from: ./
[BS] Watching files&hellip;
```</p>

<p>Browser-sync is so helpful, it will even open a browser window for you. :awthanks:</p>

<p>Don&rsquo;t forget to checkout the Chrome developer tools, which can be super helpful in creating different states for your service worker</p>

<p><img src="/images/161015-service-workers/service-worker-dev-tools.png"></p>

<hr />

<h2>MOAR Resources</h2>

<p>For more about the service worker API, checkout these resources:</p>

<ul>
<li>the <a href="https://www.w3.org/TR/service-workers/">W3C spec</a></li>
<li>the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">MDN docs</a></li>
<li>and the <a href="https://github.com/mdn/sw-test/">example</a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Callbacks and the Event Loop]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/clarified-callbacks/"/>
    <updated>2016-10-12T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/clarified-callbacks</id>
    <content type="html"><![CDATA[<p>When I started writing javascript in earnest a couple of years ago, I was stuck in a very procedural way of thinking &mdash; all of my functions executed synchronously. If you replaced <code>function</code> with <code>def</code> and removed all <code>var</code> keywords, you would be reading Ruby (true story: yesterday I was debugging an issue with a React module and put in a <code>binding.pry</code> instead of <code>debugger</code> :facepalm: Old habits die hard).</p>

<p>Last year, I joined a team that writes javascript in the Node.js style, using callbacks for flow control. While I became familiar with the pattern pretty quickly, the whys and wherefores were missing from my understanding. Today I am filling in the gaps by reading <a href="https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1785885588/ref=sr_1_1/161-7210115-5247461?ie=UTF8&amp;qid=1476284148&amp;sr=8-1&amp;keywords=node.js+design+patterns">Node.js Design Patterns</a> by Mario Casciaro and Luciano Mammino.<!--more--></p>

<h3>The Event Loop</h3>

<p>The first step to understanding asynchronous javascript is to understand the event loop. It is a single thread that processes one message at a time, as they appear in the FIFO event queue.</p>

<p><img src="/images/161012-callbacks/event-loop.png">
<em>image credit: Mario Casciaro and Luciano Mammino from Node.js Design Patterns. Colour notations are mine.</em></p>

<ol>
<li>An I/O request is sent to the event demultiplexer.</li>
<li>The event demultiplexer queues the I/O instructions along with the context and a callback function that contains the instructions for what do to with the result once it is received.</li>
<li>When the I/O order is filled, the event demultiplexer pops an event on to the event queue, with the filled I/O request, and the callback handler.</li>
<li>The event loop pulls the event off of the event queue and applies the result to the callback function.</li>
<li>The event loop either sends the result of the callback operation to the application, or generates more I/O work for the event demultiplexer.</li>
</ol>


<p>When I check my email in the morning, I go through a similar process:</p>

<ul>
<li>My inbox is the event demultiplexer, where requests for resources are made.</li>
<li>I (as the event loop) process emails from in the queue from oldest to newest, and I only process one at at time.</li>
<li>For each message I read the context and perform one of two actions (callback):

<ul>
<li>Process the message and return to the queue to pick up another message.</li>
<li>Add a new action to my todo list event queue along with the a reminder to attach the result of the new action to the email when I respond (callback).</li>
</ul>
</li>
</ul>


<p>When I am finished with my email inbox I start on my todo list, performing the actions required and responding to the email. Sometimes the action will generate additional actions, which I append to the end of my todo list. While the idea of an infinite todo list is a little disheartening to a human, this is how the V8 javascript engine was designed: it performs the work with maximum efficiency, and can do so with only a single thread.</p>

<h3>The difference between synchronous and asynchronous javascript</h3>

<p>Synchronous javascript can be easily identified by the use of a <code>return</code> statement, which returns control back to the caller.</p>

<p>```javascript
function introduction (firstName, lastName) {
  return &lsquo;Hello, my name is &rsquo; + firstName + &lsquo; &rsquo; + lastName
}</p>

<p>introduction(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;)
// &ldquo;hello! my name is Keighty Leonard&rdquo;
```</p>

<p>Asynchronous javascript uses a &lsquo;continuous passing pattern&rsquo;, where the result of a function is passed to a handler for further processing.</p>

<p>```javascript
function createEmailAddress (firstName, lastName, callback) {
  // create asynchronous call
  console.log(&lsquo;before the async&rsquo;)
  setTimeout(function () {</p>

<pre><code>// do some work
var email = firstName.toLowerCase() + '.' + lastName.toLowerCase() + '@example.com'
console.log('during the async')
// pass the result of the work to the callback
callback(email)
</code></pre>

<p>  }, 2000)
  console.log(&lsquo;after the async&rsquo;)
}</p>

<p>var cb = function (result) {
  console.log(result)
}</p>

<p>createEmailAddress(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;, cb)</p>

<p>// > before the async
// > after the async
// > during the async
// > <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x6b;&#101;&#x69;&#103;&#x68;&#x74;&#x79;&#x2e;&#108;&#x65;&#111;&#x6e;&#97;&#114;&#x64;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#107;&#x65;&#105;&#x67;&#x68;&#x74;&#121;&#x2e;&#108;&#x65;&#111;&#x6e;&#x61;&#114;&#100;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a>
```</p>

<p><code>createEmailAddress</code> is called. When execution reaches the setTimeout function, and the 2000ms have elapsed, the callback passed to setTimeout is placed in the event queue, awaiting its turn for execution. The thread is release and does not have to wait for the setTimeout period to elapse before continuing execution &mdash; it continues with the second console statement (&lsquo;after the async&rsquo;). When the setTimeout callback is finally processed, the <code>firstName</code> and <code>lastName</code> variables are still accessible because they exist in the function closure.</p>

<p>Javascript has many features that make the continuous passing pattern easy:</p>

<ul>
<li>Closures allow you to access the environment on which a function was created, no matter when the callback is invoked.</li>
<li>Functions are first class data types, meaning they can be assigned to variables, passed as parameters, and stored in data structures.</li>
</ul>


<hr />

<p>More on the event loop and event-emitter observer pattern to come!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Importing and Exporting: Modular React]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react/"/>
    <updated>2016-08-18T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react</id>
    <content type="html"><![CDATA[<p>While working on rewriting my side-project (VirtualPlaybill) in React, I got hung up on a very basic plumbing concept: named exports. <!--more--></p>

<p>With ES5 you can export in three ways and import in one:
```javascript
// EXPORT STYLE 1
module.exports = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
};</p>

<p>// EXPORT STYLE 2
exports.crunchy = function() { console.log(&lsquo;CRUNCHY!&rsquo;) }
exports.bacon = function() { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// EXPORT STYLE 3 (and my personal favourite)
var breakfast = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
}
module.exports = breakfast
```</p>

<p>An export is a meaningful bundle of code. Importing takes a single form, providing a handle to the exported bundle:</p>

<p>```javascript
// IMPORT
var breakfast = require(&lsquo;breakfast.js&rsquo;)</p>

<p>breakfast.crunchy() // CRUNCHY!
breakfast.bacon() // BACON!
```</p>

<p>In ES6 there is a lot more flexibility: exports can be named and imports can take many forms.</p>

<h4>Named exports</h4>

<p>Importing a named export allows you to grab only the functions you need from a module, leaving the rest behind. Use curly braces to import a named export:
```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY NAME
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import { crunchy } from &lsquo;./test&rsquo;
crunchy() // CRUNCHY!
bacon() // Uncaught ReferenceError: bacon is not defined(…)
```</p>

<h4>Default exports</h4>

<p>In addition to named exports, you can specify one <code>default</code> export per file. Simply importing that file provides a reference to the default export:</p>

<p>```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
default export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY DEFAULT
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import myFunc from &lsquo;./test&rsquo;
myFunc() // BACON!
```</p>

<p>You can also import both default and named exports at the same time:
<code>javascript
import myFunc, { crunchy } from './test'
crunchy() // CRUNCHY!
myFunc() // BACON!
</code></p>

<p>For even more import options, checkout the section on imports from the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">MDN docs</a>:</p>

<p><code>javascript
import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as name from "module-name";
import "module-name"
</code></p>

<p>name</p>

<blockquote><p>Name of the object that will receive the imported values.</p></blockquote>

<p>member, memberN</p>

<blockquote><p>Name of the exported members to be imported.</p></blockquote>

<p>defaultMember</p>

<blockquote><p>Name of the exported default to be imported.</p></blockquote>

<p>alias, aliasN</p>

<blockquote><p>Name of the object that will receive the imported property</p></blockquote>

<p>module-name</p>

<blockquote><p>The name of the module to import. This is a file name.</p></blockquote>

<h4>What you CAN&rsquo;T do&hellip;</h4>

<p>&hellip; is use ES5 syntax and expect the import to know what you mean:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>export default MyComponent</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // undefined
```</p>

<p>I was trying to write ES5 in ES6! Without an explicit <code>export</code> in front of the class declaration, my default had no idea what I intended to export, so it did nothing. Adding <code>export</code> to the class definition, or even moving the whole <code>export default</code> to the class declaration does the job:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
default export class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // function MyComponent() {&hellip;}
```</p>

<p>Thanks to <a href="http://stackoverflow.com/a/31853887">this stackoverflow answer</a> for pointing me in the right direction, and <a href="http://exploringjs.com/es6/ch_modules.html">exploringjs</a> for even greater detail!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nested Routes With Expressjs]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/nested-routes-with-expressjs/"/>
    <updated>2016-04-12T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/nested-routes-with-expressjs</id>
    <content type="html"><![CDATA[<p>Whenever I need to build a quick web application I turn to <a href="http://expressjs.com/">ExpressJS</a>. It is a fast, minimal, easy to configure web server that puts the <strong>E</strong> in <a href="http://mean.io/#!/">MEAN</a>). I wanted to build a REST API for a hobby app and found that the docs for how to nest routes are relatively few (see <a href="http://codetunnel.io/an-intuitive-way-to-organize-your-expressjs-routes/">blog</a>, <a href="http://stackoverflow.com/a/25305272/1279340">stackoverflow answer</a>). Combining these two resources, I learned a simple method for keeping your routes separate while creating a nested routing structure. <!--more--></p>

<h2>The Plan</h2>

<p>I want to create routes that look like these:</p>

<ul>
<li><code>/foo</code></li>
<li><code>/foo/bar</code></li>
<li><code>/foo/42</code></li>
<li><code>/foo/42/baz</code></li>
<li><code>/foo/42/baz/123</code></li>
</ul>


<p>Using the <a href="http://expressjs.com/en/starter/generator.html">express-generator</a> and a few simple commands, you can get your server up and running fast:</p>

<p><code>
$ npm install express-generator -g
$ express myapp
$ cd myapp
$ npm install
$ npm start
</code></p>

<p>You will end up with a working directory that looks like this:</p>

<p>```
├── app.js
├── bin
│   └── www
├── node_modules
│   ├── &hellip;
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views</p>

<pre><code>├── error.jade
├── index.jade
└── layout.jade
</code></pre>

<p>```</p>

<p>Go ahead and delete the <code>/routes/users.js</code> file and the following lines from <code>app.js</code></p>

<p><code>javascript app.js
...
var users = require('./routes/users');
...
app.use('/users', users);
</code></p>

<p>Then create a new routes file named <code>/routes/foo.js</code> and and require it from your app server.
<code>javascript app.js
...
app.use('/foo', require('./routes/foo'));
...
</code></p>

<h2>How to <code>GET /foo</code></h2>

<p>Inside <code>/routes/foo.js</code>, you need to require the router module from ExpressJS, define a route on it, and export it back out.</p>

<p>```javascript /routes/foo.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()</p>

<p>// GET /foo
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for foo&rsquo;)
})</p>

<p>module.exports = router
```</p>

<p>Everytime you change a route, you need to restart your server. Nevigating to <a href="http://localhost:3000/foo">localhost:3000/foo</a> should display the message:</p>

<p><img src="/images/160412-nested-routes/foo.png"></p>

<h2>How to <code>GET /foo/bar</code></h2>

<p>Create simple nested routes by requiring the child route file from the parent route file.</p>

<p>```javascript /routes/foo.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()
var bar = require(&lsquo;./bar&rsquo;)</p>

<p>// GET /foo
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for foo&rsquo;)
});</p>

<p>// GET /foo/bar
router.use(&lsquo;/bar&rsquo;, bar) // tell the router to use bar.js for child routes</p>

<p>module.exports = router
```</p>

<p>Create a new routes file named <code>/routes/bar.js</code> and define a root route the same way you did for <code>/routes/foo.js</code>:</p>

<p>```javascript /routes/bar.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router()</p>

<p>// GET /foo/bar
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the index for bar&rsquo;)
});</p>

<p>module.exports = router
```</p>

<p>Bounce your server again and navigate to <a href="http://localhost:3000/foo/bar">localhost:3000/foo/bar</a></p>

<p><img src="/images/160412-nested-routes/foobar.png"></p>

<h2>How to <code>GET /foo/42</code></h2>

<p>Expecting a parameter? No problem! access URL params directly from the request object: <code>req.params.nameOfParam</code>:</p>

<p>```javascript /routes/foo.js
&hellip;
// GET /foo/42
router.get(&lsquo;/:number&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is foo #&rsquo; + req.params.number)
})</p>

<p>module.exports = router
```
Navigate to <a href="http://localhost:3000/foo/42">localhost:3000/foo/42</a> to see the result.</p>

<p><img src="/images/160412-nested-routes/fooNumber.png"></p>

<h2>How to <code>GET /foo/42/baz</code></h2>

<p>Getting a child route from a parameterized parent is where I was getting confused. It turns out that you need to configure the router a little differently when you are passing params through.</p>

<p>```javascript /routes/foo.js
&hellip;
var baz = require(&lsquo;./baz&rsquo;)</p>

<p>&hellip;
// GET /foo/42/baz
router.use(&lsquo;/:number/baz&rsquo;, baz)</p>

<p>module.exports = router
```</p>

<p>You need to pass an options object to <code>express.Router</code> to merge the params from any parent route:</p>

<p>```javascript /routes/baz.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router({mergeParams: true}) // don&rsquo;t forget the parent params!</p>

<p>// GET /foo/42/baz
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  // the param name is from the parent as well
  res.send(&lsquo;this is the baz for foo#&rsquo; + req.params.number);
})</p>

<p>module.exports = router
```</p>

<p>Navigate to <a href="http://localhost:3000/foo/42/baz">localhost:3000/foo/42/baz</a> to enjoy your success.</p>

<p><img src="/images/160412-nested-routes/fooNumberBaz.png"></p>

<h2>How to <code>GET /foo/42/baz/123</code></h2>

<p>Parameterizing a child route is the same process as for the parent route:</p>

<p>```javascript /routes/baz.js
var express = require(&lsquo;express&rsquo;)
var router = express.Router({mergeParams: true})</p>

<p>// GET /foo/42/baz
router.get(&lsquo;/&rsquo;, function (req, res, next) {
  res.send(&lsquo;this is the baz for foo#&rsquo; + req.params.number);
})</p>

<p>// GET /foo/42/baz/123
router.get(&lsquo;/:id&rsquo;, function (req, res, next) {
  res.send(&lsquo;baz #&rsquo; + req.params.id + ‘ for foo #’ + req.params.number)
})</p>

<p>module.exports = router
```</p>

<p>Navigate to <a href="http://localhost:3000/foo/42/baz/123">localhost:3000/foo/42/baz/123</a> to enjoy your success.</p>

<p><img src="/images/160412-nested-routes/fooNumberBazNumber.png"></p>

<p>TADA! a model of nested routes that you can apply to any application.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Preflight Check With CORS]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/preflight-check-with-cors/"/>
    <updated>2016-03-29T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/preflight-check-with-cors</id>
    <content type="html"><![CDATA[<p>Modern web applications can draw resources from anywhere on the web. Fonts, JavaScript libraries, images, and other data can be fetched from CDNs, Amazon, IMDB, or anywhere else that provides a public API. Early browsers restricted web applications to same-origin requests, which prevented the sharing of resources between applications, but also ensured that data from one application could not be tampered with by another. The thinkers at the W3C came up with a means of communicating safe cross-origin requests that would allow even destructive remote actions to be performed, as long as the server consented to receive the request. Enter CORS, and preflighting.</p>

<!--more-->


<h3>What is CORS?</h3>

<p>Cross-Origin Resource Sharing occurs when JavaScript on a web page requests data from (or sends data to) a location on a different host. Any website that embeds a video from YouTube, uses a custom font, or posts to social media on your behalf, is making a CORS request. CORS is a <a href="https://www.w3.org/TR/cors/">set of web standards</a> developed to enable safe cross-domain communication.</p>

<h3>What is preflighting?</h3>

<p>CORS functions through the specification of new HTTP headers that allow servers to describe the origin and nature of the request. For each outgoing request to a different domain, the browser will look at the headers to determine if the request that looks like it will affect data on the receiving server. Any simple request that uses one of the common HTTP verbs and a basic Content-Type are allowed to pass without further comment. But if the request has different header values, the browser checks with the server first to make sure the request is expected. This is called a pre-flight check.</p>

<h3>What does a simple CORS request look like?</h3>

<p>For simple requests (no pre-flight check), the method must be one of:</p>

<pre><code>- GET
- HEAD
- POST
</code></pre>

<p>The only extra headers allowed are:</p>

<pre><code>- Accept
- Accept-Language
- Content-Language
- Content-Type
</code></pre>

<p>For the Content-Type header, the only allowed values are:</p>

<pre><code>- application/x-www-form-urlencoded
- multipart/form-data
- text/plain
</code></pre>

<p>XMLHttpRequests (aka XHRs or ajax) use CORS to mitigate the risks of pulling or pushing sensitive data across domains. For example:</p>

<p><code>javascript
var body = 'very safe, ordinary text content'
var url = 'http://api.example.com'
var request = new XMLHttpRequest()
request.open('POST', url, true)
request.setRequestHeader('Content-Type', 'text/plain')
request.send()
</code></p>

<p><img src="/images/160329-preflight-cors/cors-without-preflight.png"></p>

<p>The browser checks out the request, sees that it is unlikely to have any negative consequences, and passes it along to the requested endpoint. In the Network tab, simple CORS requests will appear by themselves:</p>

<p><img src="/images/160329-preflight-cors/one-request.png"></p>

<h3>What does a pre-flight CORS request look like?</h3>

<p>For non-simple requests, the method could be any of the HTTP verbs along with any other combination of headers. For example:</p>

<p><code>javascript
var body = 'possibly unstable or malicious content'
var url = 'http://api.example.com'
var request = new XMLHttpRequest()
request.open('POST', url, true)
request.setRequestHeader('Content-Type', 'application/json')
request.send()
</code></p>

<p>In this request I am trying to POST a JSON object to an API endpoint, which could potentially have destructive consequences for data on the other side of the endpoint. When the browser inspects the headers of this request it gets suspicious, and fires off a preliminary request to the endpoint with the meta data from the request:</p>

<p><img src="/images/160329-preflight-cors/cors-with-preflight.png"></p>

<p>The server at the endpoint responds to the pre-flight request with a list of authorized headers, including acceptable request origins, content, and actions.</p>

<p>Ignoring for a moment that the requests fail (because api.example.com does not exist), the non-simple CORS request produces two requests instead of one:
<img src="/images/160329-preflight-cors/two-requests.png"></p>

<p>The result of the pre-flight OPTIONS request will determine if the second is ever sent on to the endpoint. This is how browsers keep your application data secure from malicious or unintended changes.</p>

<h3>Why OPTIONS, and not POST?</h3>

<p>I found <a href="http://stackoverflow.com/a/16945321">this great answer</a> on stackoverflow that explains why the creators of CORS made a new request type, <code>OPTIONS</code>. Before the CORS standards were introduced, neither browsers nor servers knew how to handle cross-domain requests. Browsers would throw an error, but servers would process the request without concern. Inventing a new method type that CORS-enabled browsers AND CORS-aware servers could handshake with ensures that both sides are sensible to the meaning of the pre-flight request.</p>

<h4>RESOURCES</h4>

<ul>
<li>Learn more about the web standards at <a href="https://www.w3.org/TR/cors/">W3C</a></li>
<li>Find out more about how CORS is <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests:">implemented at Mozilla</a></li>
<li>Find out what web browsers support CORS at <a href="http://caniuse.com/#search=CORS">caniuse.com</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
