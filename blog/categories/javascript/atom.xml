<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2016-12-10T12:16:50-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    <email><![CDATA[keighty.leonard@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Browser-sync Is the Easiest Webserver EVER]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/browser-sync-webserver/"/>
    <updated>2016-10-23T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/browser-sync-webserver</id>
    <content type="html"><![CDATA[<p><a href="https://www.browsersync.io/">Browser-sync</a> is the fastest way to spin up a local web server. It will even open your default browser with the entry point you specify, and live-reload your changes as you make them. It couldn&rsquo;t possibly be any simpler to test out a site you&rsquo;re developing locally.</p>

<!--more-->


<h2>1. Install browser-sync</h2>

<p>To get started, install the browser-sync package from npm:</p>

<p><code>bash
$ npm install -g browser-sync
</code></p>

<h2>2. Configure the server</h2>

<p>Setup a simple static project folder like this (<a href="https://gist.github.com/keighty/9e5eb136c27b6a4f98f7c4f49d749256">gist</a>):</p>

<p><code>bash
.
├── bs-config.js
├── foo
│   └── index.html
└── index.html
</code></p>

<p>In your bs-config.js file, list the configuration options for how browser-sync should serve your files, including which file extensions it should watch for changes (<code>"*html","*js","*css"</code>), and what resources should be served by a new route name (<code>"/foo": "foo"</code>).</p>

<p>```javascript
// bs-config.js</p>

<p>module.exports = {</p>

<pre><code>"files": ["*html","*js","*css"],
"server": true,
"port": 3000,
"routes": {
  "/foo": "foo"
}
</code></pre>

<p>};
```
 Checkout all the options available in the <a href="https://www.browsersync.io/docs/options"> docs</a>.</p>

<p> For this example, I have also included an entry point at index.html, and an additional html file to try a new route:</p>

<p>```html</p>

<!-- index.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;INDEX&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;p&gt;
  This is the index
&lt;/p&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>```html</p>

<!-- foo/index.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;FOO&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;p&gt;
  This is a foo
&lt;/p&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Now that you have a sample project outlined, start the server.</p>

<h2>3. Start the web server</h2>

<p><code>$ browser-sync start --config bs-config.js</code></p>

<p>Browser-sync will open your default web browser and load the index.html file:</p>

<p><img src="/images/161023-browser-sync/https2.png"></p>

<p>Test out the router by navigating to <code>localhost:3000/foo</code>, and you should see the content of <code>foo/index.html</code></p>

<p><img src="/images/161023-browser-sync/routes.png"></p>

<p>Serving a local site is just that quick. If you don&rsquo;t know where to start with your bs-config.js file, you can have browser-sync generate one for you:</p>

<p><code>bash
$ mkdir testserver &amp;&amp; cd testserver
$ browser-sync init
[BS] Config file created bs-config.js
[BS] To use it, in the same directory run: browser-sync start --config bs-config.js
</code></p>

<p>In the generated config file, you find all the options that are used internally, but there are many more described on the <a href="http://www.browsersync.io/docs/options/">website</a>:</p>

<p>```javascript
module.exports = {</p>

<pre><code>"ui": {
    "port": 3001,
    "weinre": {
        "port": 8080
    }
},
"files": false,
"watchOptions": {},
"server": false,
"proxy": false,
"port": 3000,
"middleware": false,
"serveStatic": [],
"ghostMode": {
    "clicks": true,
    "scroll": true,
    "forms": {
        "submit": true,
        "inputs": true,
        "toggles": true
    }
},
"logLevel": "info",
"logPrefix": "BS",
"logConnections": false,
"logFileChanges": true,
"logSnippet": true,
"rewriteRules": [],
"open": "local",
"browser": "default",
"cors": false,
"xip": false,
"hostnameSuffix": false,
"reloadOnRestart": false,
"notify": true,
"scrollProportionally": true,
"scrollThrottle": 0,
"scrollRestoreTechnique": "window.name",
"scrollElements": [],
"scrollElementMapping": [],
</code></pre>

<p>&hellip;
```</p>

<p>For example: to <a href="https://www.browsersync.io/docs/options#option-https">test your application over https</a>, set <code>"https": true</code> right beneath your server options. When browser-sync opens the browser with your entry point, the browser should warn you that the connection isn&rsquo;t safe:</p>

<p><img src="/images/161023-browser-sync/https.png"></p>

<p>Click on <code>Proceed to localhost (unsafe)</code> to load your content.</p>

<p>Easy peasy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service Workers]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/service-workers/"/>
    <updated>2016-10-15T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/service-workers</id>
    <content type="html"><![CDATA[<p>A service worker is a script that sits between a web page and the network, acting as a proxy for network requests: if the network is available, the request is passed on to the target url; if the network is not available, the service worker will handle the request itself by checking cached responses or or queuing the request for synchronization once the network is available. Service workers are bridging the gap between native mobile applications and traditional web applications that require a network connection to function. Sometimes called progressive web apps, these applications enable a seamless offline experience when the user is not connected to a network.</p>

<!--more-->


<p>Service workers can be used for data synchronization in the background, but data fetching and sync-ing are only one of the ways we can leverage this API. We can:</p>

<ul>
<li>use background resources to perform client-side compilation of assets  (useful for web development)</li>
<li>pre-fetch data that the user is likely going to need in the near future (think photo albums or playlists)</li>
<li>share large data sets between multiple pages</li>
<li>notify mobile users of updates via push notifications</li>
</ul>


<p>For example, <a href="https://www.washingtonpost.com/">The Washington Post</a> uses service workers to send push notifications of breaking news content to users of their web application on android.</p>

<h2>How do they work?</h2>

<p>Service workers rely on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise API</a> &mdash; a Promise is a proxy for &ldquo;a value that may be  available now, or in the future, or never.&rdquo; They also use the event emitter pattern, where listeners are registered to handle specific events, such as <code>fetch</code> requests.</p>

<p>To employ a service worker you must first register a script with the service worker API: <code>navigator.serviceWorker.register('./sw.js')</code>. Checkout the following example (<a href="https://gist.github.com/keighty/ec1a37a0f6475d7cdf2db64b01eff445.js">get the gist</a>):</p>

<p>```html</p>

<!-- index.html references the javascript application -->


<p><html>
  <body></p>

<pre><code>&lt;h1&gt;Service worker test app&lt;/h1&gt;
&lt;script src="./app.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
<code>
</code>javascript
// app.js
.register(&lsquo;sw.js&rsquo;) // register a worker script with the service
navigator.serviceWorker
  .then(function(reg) {</p>

<pre><code>// do the following if registration is successful
if(reg.installing) {
  // first visit or fresh reload of the worker
  console.log('Service worker installing on registration.');
} else if(reg.waiting) {
  // a worker may be installed but waiting for another worker to stop
  console.log('Service worker already installed on registration.');
} else if(reg.active) {
  // pages from the same origin may share a service worker
  console.log('Service worker already active on registration.');
}
</code></pre>

<p>  }).catch(function(error) {</p>

<pre><code>// if registration is unsuccessful, tell us why
console.log('Registration failed with ' + error);
</code></pre>

<p>  });
<code>
</code>javascript
// sw.js
console.log(&lsquo;inside registration script&rsquo;)</p>

<p>this.addEventListener(&lsquo;install&rsquo;, function(event) {
  console.log(&lsquo;Service worker installed.&rsquo;)
});</p>

<p>this.addEventListener(&lsquo;activate&rsquo;, function (event) {
  console.log(&lsquo;Service worker activated.&rsquo;)
})
```</p>

<p>Service workers can be registered with a specific origin and path to watch. Since they run in a background thread with a context separate from the application javascript, service workers have no DOM access. So don&rsquo;t try to perform synchronous work (like accessing LocalStorage) or update the DOM from a service worker.</p>

<p>Running this example code sends some output to the console:
<img src="/images/161015-service-workers/service-worker-demo1.png"></p>

<h4>NOTE: A single service worker can control many pages (so be careful with global variables).</h4>

<p><img src="/images/161015-service-workers/service-worker-demo2.png"></p>

<h2>Developing with service workers</h2>

<p>Service workers can only function in a secure context, which means that you can only register a service worker from a web application that is served over <code>https</code>. One option is to use <a href="https://pages.github.com/">GitHub pages</a> to deploy your application, as these pages are generally served over <code>https</code>. Another option is to use a local web server (<code>localhost</code> is considered semi-secure).</p>

<p>I use <a href="https://www.browsersync.io/">Browser-sync</a>, a super light-weight easy to start web server. In my project directory, I start the browser-sync server and set it to watch my javascript files:</p>

<p>```bash
$ npm install -g browser-sync
$ browser-sync start &mdash;server &mdash;files *.js
[BS] Access URLs:</p>

<hr />

<pre><code>   Local: http://localhost:3000
External: http://10.0.0.8:3000
</code></pre>

<hr />

<pre><code>      UI: http://localhost:3001
</code></pre>

<p> UI External: <a href="http://10.0.0.8:3001">http://10.0.0.8:3001</a></p>

<hr />

<p>[BS] Serving files from: ./
[BS] Watching files&hellip;
```</p>

<p>Browser-sync is so helpful, it will even open a browser window for you. :awthanks:</p>

<p>Don&rsquo;t forget to checkout the Chrome developer tools, which can be super helpful in creating different states for your service worker</p>

<p><img src="/images/161015-service-workers/service-worker-dev-tools.png"></p>

<hr />

<h2>MOAR Resources</h2>

<p>For more about the service worker API, checkout these resources:</p>

<ul>
<li>the <a href="https://www.w3.org/TR/service-workers/">W3C spec</a></li>
<li>the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">MDN docs</a></li>
<li>and the <a href="https://github.com/mdn/sw-test/">example</a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The EventEmitter Pattern and the Event Loop -- a Timeline]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/event-emitter-and-event-loop/"/>
    <updated>2016-10-14T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/event-emitter-and-event-loop</id>
    <content type="html"><![CDATA[<p>The EventEmitter pattern is a derivative of the Observer pattern: an object can notify a set of observers when a change in its state occurs.<!--more--> Consider the following example using the EventEmitter pattern:</p>

<p>```javascript
const EventEmitter = require(&lsquo;events&rsquo;).EventEmitter
const fs = require(&lsquo;fs&rsquo;)</p>

<p>const findPattern = (files, regex) => {
  const emitter = new EventEmitter()</p>

<p>  files.forEach(file => {</p>

<pre><code>fs.readFile(file, 'utf8', (err, content) =&gt; {
  if (err) return emitter.emit('error', err)

  emitter.emit('fileread', file)

  let match
  if (match = content.match(regex)) {
    match.forEach(elem =&gt; {
      emitter.emit('found', file, elem)
    })
  }
})
</code></pre>

<p>  })
  return emitter
}</p>

<p>// fileA.txt contains the words &ldquo;hello blah blah blah&rdquo;
// fileB.json is empty
// fileC.md does not exist
const files = [&lsquo;fileA.txt&rsquo;, &lsquo;fileB.json&rsquo;, &lsquo;fileC.md&rsquo;]</p>

<p>findPattern(files, /hello \w+/g)
  .on(&lsquo;fileread&rsquo;, file => {console.log(<code>${file} was read</code>)})
  .on(&lsquo;found&rsquo;, (file, match) => {console.log(<code>Matched ${match} in file ${file}</code>)})
  .on(&lsquo;error&rsquo;, err => {console.log(<code>Error emitted: ${err.message}</code>)})
```</p>

<p>Some of the script is executed synchronously, but the real work is done asynchronously. The EventEmitter pattern takes advantage of the event loop to work efficiently.</p>

<p>Keep the following schematic in mind as you parse through the execution of this script:</p>

<p><img src="/images/161012-callbacks/event-loop.png"></p>

<p><em>image credit: Mario Casciaro and Luciano Mammino from Node.js Design Patterns. Colour notations are mine.</em></p>

<p>The first set of operations happen synchronously:</p>

<ul>
<li>call <code>findPattern</code> with the file list and regex pattern</li>
<li>create a new event emitter</li>
<li>submit <code>readFile</code> I/O request for fileA.txt to the event demultiplexer</li>
<li>submit <code>readFile</code> I/O request for fileB.json to the event demultiplexer</li>
<li>submit <code>readFile</code> I/O request for fileC.md to the event demultiplexer</li>
<li>return the event emitter</li>
<li>register <code>fileread</code> listener on the event emitter</li>
<li>register <code>found</code> listener on the event emitter</li>
<li>register <code>error</code> listener on the event emitter</li>
</ul>


<p><img src="/images/161014-event-emitter/event-emitter-1.png"></p>

<p>Once the I/O operations are submitted to the event demultiplexer, they will return in the order in which the requests are fulfilled. In this example, fileC.md does not exist, so the event demultiplexer submits the result along with the handler to the Event loop.</p>

<ul>
<li>The event loop runs the result through the callback for fileC.md, which <strong>emits an error event</strong> (line 9)! The EventEmitter adds the error handler to the event loop.</li>
</ul>


<p><img src="/images/161014-event-emitter/event-emitter-2.png"></p>

<p>In the meantime, the event demultiplexer has fulfilled the I/O request for fileB.json, and added the result and the callback to the event loop.</p>

<ul>
<li>The event loop runs the result through the callback for fileB, which emits a <code>fileread</code> event (line 11). The EventEmitter adds the <code>fileread</code> handler to the event loop.</li>
</ul>


<p>The event demultiplexer also fulfills the I/O request for fileA.txt and adds the result and the callback to the event loop.</p>

<ul>
<li>The event loop runs the result through the callback for fileA, which emits a <code>fileread</code> event (line 11) AND a <code>found</code> event (line 16). The EventEmitter adds the <code>fileread</code> and <code>found</code> handlers to the event loop.</li>
</ul>


<p>The event loop is busily processing all of these events in the order of arrival:</p>

<ul>
<li>run the listener callback for the <code>error</code> event (fileC)</li>
<li>run the listener callback for the <code>fileread</code> event (fileB)</li>
<li>run the listener callback for the <code>fileread</code> event (fileA)</li>
<li>FINALLY &mdash; run the listener callback for the <code>found</code> event (fileA)</li>
</ul>


<p>The result of running this script on the command line:</p>

<p><code>text
$ node --use_strict events.js
Error emitted: ENOENT: no such file or directory, open 'fileC.md'
fileB.json was read
fileA.txt was read
Matched hello blah in file fileA.txt
</code></p>

<p><em>Side note: set the flag <code>--use-strict</code> to run scripts using ES6 syntax</em></p>

<p>Why did the files process in what seems to be reverse order? The event demultiplexer adds work to the event loop as it fulfills I/O requests. When <code>readfile()</code> is given three files &mdash; a file with content (fileA), an empty file (fileB), and a non-existent file (fileC) &mdash; it is reasonable to assume that the I/O request for a non-existent file will return first, as there is no file to read. It is also reasonable that an empty file will  return next, as there is very little work to be done reading an empty file. Finally, the I/O request for the file with content returns &mdash; it requires more work to read a file with content than an empty file.</p>

<p>For more about the event emitter pattern in Node, check out <a href="https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1785885588/ref=sr_1_1/161-7210115-5247461?ie=UTF8&amp;qid=1476284148&amp;sr=8-1&amp;keywords=node.js+design+patterns">Node.js Design Patterns</a> by Mario Casciaro and Luciano Mammino.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Callbacks and the Event Loop]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/clarified-callbacks/"/>
    <updated>2016-10-12T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/clarified-callbacks</id>
    <content type="html"><![CDATA[<p>When I started writing javascript in earnest a couple of years ago, I was stuck in a very procedural way of thinking &mdash; all of my functions executed synchronously. If you replaced <code>function</code> with <code>def</code> and removed all <code>var</code> keywords, you would be reading Ruby (true story: yesterday I was debugging an issue with a React module and put in a <code>binding.pry</code> instead of <code>debugger</code> :facepalm: Old habits die hard).</p>

<p>Last year, I joined a team that writes javascript in the Node.js style, using callbacks for flow control. While I became familiar with the pattern pretty quickly, the whys and wherefores were missing from my understanding. Today I am filling in the gaps by reading <a href="https://www.amazon.com/Node-js-Design-Patterns-Mario-Casciaro/dp/1785885588/ref=sr_1_1/161-7210115-5247461?ie=UTF8&amp;qid=1476284148&amp;sr=8-1&amp;keywords=node.js+design+patterns">Node.js Design Patterns</a> by Mario Casciaro and Luciano Mammino.<!--more--></p>

<h3>The Event Loop</h3>

<p>The first step to understanding asynchronous javascript is to understand the event loop. It is a single thread that processes one message at a time, as they appear in the FIFO event queue.</p>

<p><img src="/images/161012-callbacks/event-loop.png">
<em>image credit: Mario Casciaro and Luciano Mammino from Node.js Design Patterns. Colour notations are mine.</em></p>

<ol>
<li>An I/O request is sent to the event demultiplexer.</li>
<li>The event demultiplexer queues the I/O instructions along with the context and a callback function that contains the instructions for what do to with the result once it is received.</li>
<li>When the I/O order is filled, the event demultiplexer pops an event on to the event queue, with the filled I/O request, and the callback handler.</li>
<li>The event loop pulls the event off of the event queue and applies the result to the callback function.</li>
<li>The event loop either sends the result of the callback operation to the application, or generates more I/O work for the event demultiplexer.</li>
</ol>


<p>When I check my email in the morning, I go through a similar process:</p>

<ul>
<li>My inbox is the event demultiplexer, where requests for resources are made.</li>
<li>I (as the event loop) process emails from in the queue from oldest to newest, and I only process one at at time.</li>
<li>For each message I read the context and perform one of two actions (callback):

<ul>
<li>Process the message and return to the queue to pick up another message.</li>
<li>Add a new action to my todo list event queue along with the a reminder to attach the result of the new action to the email when I respond (callback).</li>
</ul>
</li>
</ul>


<p>When I am finished with my email inbox I start on my todo list, performing the actions required and responding to the email. Sometimes the action will generate additional actions, which I append to the end of my todo list. While the idea of an infinite todo list is a little disheartening to a human, this is how the V8 javascript engine was designed: it performs the work with maximum efficiency, and can do so with only a single thread.</p>

<h3>The difference between synchronous and asynchronous javascript</h3>

<p>Synchronous javascript can be easily identified by the use of a <code>return</code> statement, which returns control back to the caller.</p>

<p>```javascript
function introduction (firstName, lastName) {
  return &lsquo;Hello, my name is &rsquo; + firstName + &lsquo; &rsquo; + lastName
}</p>

<p>introduction(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;)
// &ldquo;hello! my name is Keighty Leonard&rdquo;
```</p>

<p>Asynchronous javascript uses a &lsquo;continuous passing pattern&rsquo;, where the result of a function is passed to a handler for further processing.</p>

<p>```javascript
function createEmailAddress (firstName, lastName, callback) {
  // create asynchronous call
  console.log(&lsquo;before the async&rsquo;)
  setTimeout(function () {</p>

<pre><code>// do some work
var email = firstName.toLowerCase() + '.' + lastName.toLowerCase() + '@example.com'
console.log('during the async')
// pass the result of the work to the callback
callback(email)
</code></pre>

<p>  }, 2000)
  console.log(&lsquo;after the async&rsquo;)
}</p>

<p>var cb = function (result) {
  console.log(result)
}</p>

<p>createEmailAddress(&lsquo;Keighty&rsquo;, &lsquo;Leonard&rsquo;, cb)</p>

<p>// > before the async
// > after the async
// > during the async
// > <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#107;&#x65;&#x69;&#103;&#x68;&#x74;&#x79;&#46;&#x6c;&#101;&#111;&#110;&#97;&#114;&#x64;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x6b;&#x65;&#105;&#103;&#104;&#x74;&#x79;&#46;&#x6c;&#101;&#111;&#x6e;&#97;&#114;&#100;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>
```</p>

<p><code>createEmailAddress</code> is called. When execution reaches the setTimeout function, and the 2000ms have elapsed, the callback passed to setTimeout is placed in the event queue, awaiting its turn for execution. The thread is release and does not have to wait for the setTimeout period to elapse before continuing execution &mdash; it continues with the second console statement (&lsquo;after the async&rsquo;). When the setTimeout callback is finally processed, the <code>firstName</code> and <code>lastName</code> variables are still accessible because they exist in the function closure.</p>

<p>Javascript has many features that make the continuous passing pattern easy:</p>

<ul>
<li>Closures allow you to access the environment on which a function was created, no matter when the callback is invoked.</li>
<li>Functions are first class data types, meaning they can be assigned to variables, passed as parameters, and stored in data structures.</li>
</ul>


<hr />

<p>More on the event loop and event-emitter observer pattern to come!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Importing and Exporting: Modular React]]></title>
    <link href="http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react/"/>
    <updated>2016-08-18T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2016/importing-and-exporting-modular-react</id>
    <content type="html"><![CDATA[<p>While working on rewriting my side-project (VirtualPlaybill) in React, I got hung up on a very basic plumbing concept: named exports. <!--more--></p>

<p>With ES5 you can export in three ways and import in one:
```javascript
// EXPORT STYLE 1
module.exports = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
};</p>

<p>// EXPORT STYLE 2
exports.crunchy = function() { console.log(&lsquo;CRUNCHY!&rsquo;) }
exports.bacon = function() { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// EXPORT STYLE 3 (and my personal favourite)
var breakfast = {
  crunchy: function () { console.log(&lsquo;CRUNCHY!&rsquo;) },
  bacon: function () { console.log(&lsquo;BACON!&rsquo;) }
}
module.exports = breakfast
```</p>

<p>An export is a meaningful bundle of code. Importing takes a single form, providing a handle to the exported bundle:</p>

<p>```javascript
// IMPORT
var breakfast = require(&lsquo;breakfast.js&rsquo;)</p>

<p>breakfast.crunchy() // CRUNCHY!
breakfast.bacon() // BACON!
```</p>

<p>In ES6 there is a lot more flexibility: exports can be named and imports can take many forms.</p>

<h4>Named exports</h4>

<p>Importing a named export allows you to grab only the functions you need from a module, leaving the rest behind. Use curly braces to import a named export:
```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY NAME
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import { crunchy } from &lsquo;./test&rsquo;
crunchy() // CRUNCHY!
bacon() // Uncaught ReferenceError: bacon is not defined(…)
```</p>

<h4>Default exports</h4>

<p>In addition to named exports, you can specify one <code>default</code> export per file. Simply importing that file provides a reference to the default export:</p>

<p>```javascript
//&mdash;&mdash;-test.js&mdash;&mdash;&ndash;//
export crunchy = () => { console.log(&lsquo;CRUNCHY!&rsquo;) }
default export bacon = () => { console.log(&lsquo;BACON!&rsquo;) }</p>

<p>// IMPORT BY DEFAULT
//&mdash;&mdash;-main.js&mdash;&mdash;&ndash;//
import myFunc from &lsquo;./test&rsquo;
myFunc() // BACON!
```</p>

<p>You can also import both default and named exports at the same time:
<code>javascript
import myFunc, { crunchy } from './test'
crunchy() // CRUNCHY!
myFunc() // BACON!
</code></p>

<p>For even more import options, checkout the section on imports from the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">MDN docs</a>:</p>

<p><code>javascript
import defaultMember from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as name from "module-name";
import "module-name"
</code></p>

<p>name</p>

<blockquote><p>Name of the object that will receive the imported values.</p></blockquote>

<p>member, memberN</p>

<blockquote><p>Name of the exported members to be imported.</p></blockquote>

<p>defaultMember</p>

<blockquote><p>Name of the exported default to be imported.</p></blockquote>

<p>alias, aliasN</p>

<blockquote><p>Name of the object that will receive the imported property</p></blockquote>

<p>module-name</p>

<blockquote><p>The name of the module to import. This is a file name.</p></blockquote>

<h4>What you CAN&rsquo;T do&hellip;</h4>

<p>&hellip; is use ES5 syntax and expect the import to know what you mean:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>export default MyComponent</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // undefined
```</p>

<p>I was trying to write ES5 in ES6! Without an explicit <code>export</code> in front of the class declaration, my default had no idea what I intended to export, so it did nothing. Adding <code>export</code> to the class definition, or even moving the whole <code>export default</code> to the class declaration does the job:</p>

<p>```javascript
//&mdash;&mdash;&mdash;my-component.js&mdash;&mdash;&mdash;&ndash;//
default export class MyComponent extends React.Component {
  render() {</p>

<pre><code>return &lt;p&gt;this is an awesome react component &lt;/p&gt;
</code></pre>

<p>  }
}</p>

<p>//&mdash;&mdash;&mdash;main.js&mdash;&mdash;&mdash;&ndash;//
import MyComponent from &lsquo;./my-component&rsquo;
console.log(MyComponent) // function MyComponent() {&hellip;}
```</p>

<p>Thanks to <a href="http://stackoverflow.com/a/31853887">this stackoverflow answer</a> for pointing me in the right direction, and <a href="http://exploringjs.com/es6/ch_modules.html">exploringjs</a> for even greater detail!</p>
]]></content>
  </entry>
  
</feed>
