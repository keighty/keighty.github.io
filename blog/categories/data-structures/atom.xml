<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Data_structures | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/data-structures/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2014-01-12T11:26:33-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[State of the QuickUnion]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/state-of-the-quickunion/"/>
    <updated>2013-08-04T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/state-of-the-quickunion</id>
    <content type="html"><![CDATA[<p>In my last look at the UnionFind algorithm I made a quick-find implementation &mdash; finding if two elements were connected was fast but connecting two elements was slow. The union operation is a good candidate for optimization.</p>

<h1>Quick Union</h1>

<p>One way to optimize the union operation is to reduce the number of array accesses required.</p>

<p>In QuickFind, the sets are arranged in a flat array of elements which all share the same value: they are all wearing the same t-shirt. When we connect elements from different sets, we must make sure that every element in the first set changes its t-shirt to match the elements in the other set. This is a time-consuming process, and uses a lot of t-shirts.</p>

<p>What if only one element had to change its t-shirt? If the set had a single element in charge &ndash; a root &ndash; then joining elements from different sets would require identifying the t-shirt of the one in charge, and then changing to that element&rsquo;s t-shirt.</p>

<p>Using an array instead of t-shirts to keep track of the values, we can walk through what this implementation would look like:</p>

<table class="table table-bordered">
  <tr>
    <th>Index</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <th></th>
  </tr>
  <tr>
    <th>Value</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <td> | Each element begins as the root of its own set</td>
  </tr>
  <tr>
    <th>union(4,9)</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td class="highlight">9</td>
    <td>0</td>
    <td> | root(9) = 9, root(4) = 4, change array[4] = 9</td>
  </tr>
  <tr>
    <th>union(2,4)</th>
    <td>1</td>
    <td class="highlight">9</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <td> | root(4) = 9, root(2) = 2, change array[2] = 9</td>
  </tr>
  <tr>
    <th>union(4,7)</th>
    <td>1</td>
    <td>9</td>
    <td>3</td>
    <td  class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td  class="highlight">7</td>
    <td>8</td>
    <td>7</td>
    <td>0</td>
    <td> | root(7) = 7, root(4) = 9, change array[9] = 7</td>
  </tr>
  <tr>
    <th>find(2,7)</th>
    <td>1</td>
    <td class="highlight">9</td>
    <td>3</td>
    <td>9</td>
    <td>5</td>
    <td>6</td>
    <td class="highlight">7</td>
    <td>8</td>
    <td class="highlight">7</td>
    <td>0</td>
    <td> | root(7) = 7, root(2) = 7. The two are connected </td>
  </tr>
</table>


<h2>QuickUnion</h2>

<p>Again following the basic API:
{% highlight java %}</p>

<h2>public class UF</h2>

<p>public UF(int N)
public int find(int p, int q)
public void union(int p, int q){% endhighlight %}</p>

<p>I adapted the QuickUnion in ruby:
{% highlight ruby linenos %}
class QuickUnion
  def initialize(size)</p>

<pre><code>@find_array = Array.new(size){ |index| index }
</code></pre>

<p>  end</p>

<p>  # check if p and q have the same root
  def find(p, q)</p>

<pre><code>verify(p, q)
root(p) == root(q)
</code></pre>

<p>  end</p>

<p>  # set id of p&rsquo;s root to the id of q&rsquo;s root
  def union(p, q)</p>

<pre><code>verify(p, q)
@find_array[root(p)] = root(q)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def root(index)
  # get root until root(index) == index
  if @find_array[index] == index
    return index
  else
    root(@find_array[index])
  end
end

def verify(p, q)
  raise NotAnElement if @find_array[p].nil?
  raise NotAnElement if @find_array[q].nil?
end
</code></pre>

<p>end</p>

<p>class NotAnElement &lt; Exception
end
{% endhighlight %}</p>

<p>This implementation is a QuickUnion because in an array of 1,000,000 entries, connecting element p to element q is easy: you only have to find the root of p, and then change q to match (one root() and one array access). Finding if p and q are connected takes a little bit longer, because you have to perform two root operations: one for p and one for q, but it is still faster than accessing every element in the array.</p>

<h2>Benchmark</h2>

<p>{% highlight bash %}
$ ruby lib/benchmark.rb
=> Array Size: 100</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.000000   0.000000   0.000000 (  0.001865)
   0.000000   0.000000   0.000000 (  0.000377)
$ ruby lib/benchmark.rb
=> Array Size: 1000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.120000   0.010000   0.130000 (  0.124929)
   0.010000   0.000000   0.010000 (  0.008825)
$ ruby lib/benchmark.rb
=> Array Size: 10000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>  10.120000   0.030000  10.150000 ( 10.146124)
   0.520000   0.000000   0.520000 (  0.520377){% endhighlight %}</p>

<p>Comparing QuickFind (top line) with QuickUnion(bottom line), we can actually measure how well this small optimization of the union operation has increased performance with larger datasets.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[State of the UnionFind]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/state-of-the-unionfind/"/>
    <updated>2013-07-30T00:00:00-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/state-of-the-unionfind</id>
    <content type="html"><![CDATA[<p>I was scraping the rust off my data-structures synapses last week, and found that there was still some functionality underneath. UnionFind is one of those sneaky algorithms that crops up in non-linear arrangements of data, such as computer or social networks. Specifically, it keeps track of sets of connected elements. The API consists of a union(p, q), which connects the two elements p and q, and a find(p, q), which determines if p is in the same set as q.</p>

<p>I learned about this algorithm through <a href="https://www.coursera.org/">Coursera</a>, and their class <a href="https://www.coursera.org/course/algs4partI">Algorithms Part 1</a> with Kevin Wayne and Robert Sedgewick. The focus of this course was not only on implementation of algorithms, but also optimization.</p>

<h1>Union Find</h1>

<p>A simple model for connectivity is 10 objects numbered 1 through 0:</p>

<p>0 1 2 3 4 5 6 7 8 9</p>

<p>Making random connections will produce disjointed sets of objects:</p>

<p>0 1 { 2 3 9 } { 5 6 } 7 { 4 8 }</p>

<p>A find(p, q) will determine if p and q are in the same set:</p>

<ul>
<li>find(0, 8) => false</li>
<li>find(2, 9) => true</li>
</ul>


<p>A union(p, q) will put p and q in the same set:</p>

<ul>
<li>union(1, 6) => 0 { 2 3 9 } { 1 5 6 } 7 { 4 8 }</li>
<li>union(2, 4) => 0 1 { 5 6 } 7 { 2 3 9 4 8 }</li>
</ul>


<p>Using an array to keep track of the values, we can walk through what this implementation would look like:</p>

<table class="table table-bordered">
  <tr>
    <th>Index</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <th></th>
  </tr>
  <tr>
    <th>Value</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td>9</td>
    <td>0</td>
    <th></th>
  </tr>
  <tr>
    <th>union(4,9)</th>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td class="highlight">9</td>
    <td>0</td>
    <td> | Changes all values that match array[4] to match array[9]</td>
  </tr>
  <tr>
    <th>union(2,4)</th>
    <td>1</td>
    <td class="highlight">9</td>
    <td>3</td>
    <td class="highlight">9</td>
    <td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
    <td class="highlight">9</td>
    <td>0</td>
    <td> | Changes all values that match array[2] to match array[4]</td>
  </tr>
  <tr>
    <th>union(4,7)</th>
    <td>1</td>
    <td class="highlight">7</td>
    <td>3</td>
    <td class="highlight">7</td>
    <td>5</td>
    <td>6</td>
    <td class="highlight">7</td>
    <td>8</td>
    <td class="highlight">7</td>
    <td>0</td>
    <td> | Changes all values that match array[4] to match array[7]</td>
  </tr>
</table>


<p>Using the java api provided by Kevin Wayne and Robert Sedgewick:</p>

<p>{% highlight java %}</p>

<h2>public class UF</h2>

<p>public UF(int N)
public int find(int p, int q)
public void union(int p, int q) {% endhighlight %}</p>

<p>I adapted the basic union find in ruby:</p>

<p>{% highlight ruby linenos%}
class QuickFind</p>

<p>  attr_accessor :find_array</p>

<p>  def initialize(size)</p>

<pre><code>@find_array = Array.new(size){ |index| index }
</code></pre>

<p>  end</p>

<p>  def find(p, q)</p>

<pre><code>location(p) == location(q)
</code></pre>

<p>  end</p>

<p>  def union(p, q)</p>

<pre><code>@find_array = create_union(p, q)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def location(index)
  raise NotAnElement if @find_array[index].nil?
  return @find_array[index]
end

def create_union(p, q)
  target = location(p)
  goal = location(q)
  temp_array = @find_array.map do |element|
    element == target ? goal : element
  end
end
</code></pre>

<p>end</p>

<p>class NotAnElement &lt; Exception
end
{% endhighlight %}</p>

<p>Sets are arranged as a flat array of elements which all share the same value: they are all wearing the same t-shirt. When we connect elements from different sets, we must make sure that every element in the first set changes its t-shirt to match the elements in the other set. This is a time-consuming process, and uses a lot of t-shirts.</p>

<p>This implementation is called QuickFind because in an array of 1,000,000 entries, finding if two elements are connected is easy (compare the t-shirt at index p with the t-shirt at index q), but connecting them requires inspection of every element in the array in order (check everyone&rsquo;s t-shirts) to make sure all the previous connections remain in place.</p>

<h2>Benchmark</h2>

<p>To compare efficiency of this and future UnionFind implementations, I built a basic benchmark that performs a set number of union and find operations and measures the time to completion:
{% highlight ruby %}
require &lsquo;benchmark&rsquo;
@size = 10000</p>

<p>def testUnit(object)
  @size.times do</p>

<pre><code>object.union(rand(@size), rand(@size))
object.find(rand(@size), rand(@size))
</code></pre>

<p>  end
end</p>

<p>Benchmark.bm do |x|
  x.report { testUnit(QuickFind.new(@size)) }
end
{% endhighlight %}</p>

<p>Running the benchmark on QuickFind:</p>

<p>{% highlight bash %}
$ ruby lib/benchmark.rb
=> Array size = 100</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.000000   0.000000   0.000000 (  0.002745)
$ ruby lib/benchmark.rb
=> Array size = 1000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>   0.140000   0.000000   0.140000 (  0.137957)
$ ruby lib/benchmark.rb
=> Array size = 10000</p>

<pre><code>   user     system      total        real
</code></pre>

<p>  13.790000   0.020000  13.810000 ( 13.866528){% endhighlight %}</p>

<p>You can see from these measurements that increasing the size of the array by a factor of 10 each time comes with a logarithmic increase in processing time. There is definitely room for optimization, so stay tuned for more refinements. In the meantime,</p>

<h2>Fun Rubyisms</h2>

<p>Array initialization is a snap in ruby! Compare the initialization line in the QuickFind algorithm above with the equivalent java implementation:
{% highlight ruby %}
@find_array = Array.new(size){ |index| index }
{% endhighlight %}
versus
{% highlight java %}
&hellip;
int[] arry = new int[size]
for (int i = 0; i &lt; size; i++) {</p>

<pre><code>id[i] = i;
</code></pre>

<p>}
{% endhighlight %}</p>

<p>Both result in an array of the specified size, but ruby is slightly less sprawling.</p>

<p>Also, check out lines 27 &ndash; 29
{% highlight ruby %}
temp_array = @find_array.map do |element|
  element == target ? goal : element
end
{% endhighlight %}</p>

<p>Using map() eliminates the need for a separate array declaration. It is the equivalent of:
{% highlight ruby %}
temp_array = []
@find_array.each do |element|
  temp_array &lt;&lt; element == target ? goal : element
end
return temp_array {% endhighlight %}</p>

<p>and is certainly more readable than the equivalent in java:
{% highlight java %}
int pid = id[p];
for (int i = 0; i &lt; id.length; i++)</p>

<pre><code>if (id[i] == pid) id[i] = id[q];
</code></pre>

<p>{% endhighlight %}</p>

<p>Awesome</p>
]]></content>
  </entry>
  
</feed>
