<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Eh | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/eh/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2014-02-13T19:43:36-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Runtime for Your Life]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/runtime-for-your-life/"/>
    <updated>2013-08-19T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/runtime-for-your-life</id>
    <content type="html"><![CDATA[<p>Eh? is coming along as a functioning interpreted language, but we are still missing a runtime. We have a lexer that chops and tags our code string into tokens, and a grammar that contains the rules for order of operations, and a parser that is generated by RACC from the grammar. The parser assembles the tokens into an evaluation tree (AST), but we need a runtime to do the actual evaluation.</p>

<!--more-->


<p>Recall from my previous post that the AST consists of nodes, like this one for a method definition:</p>

<p>{% highlight ruby %}
class DefNode
  def initialize(name, params, body)</p>

<pre><code>@name = name
@params = params
@body = body
</code></pre>

<p>  end</p>

<p>  def eval(context)</p>

<pre><code>context.current_class.can_methods[@name] = CanMethod.new(@params, @body)
</code></pre>

<p>  end
end{% endhighlight %}</p>

<p>When a method definition node is evaluated it adds a new entry to the can_methods hash. The name of the method is its key, and the value is an object (CanMethod.new) that contains the details of method evaluation (parameters and the method body). The context is the scope of the evaluation &ndash; in the case of a method call, the context is the enclosing class.</p>

<p>Ok, so when does the CanMethod get evaluated? It happens at runtime. A class node is built and all the method definitions are added, but the node tree will remain untouched until until a method is called.</p>

<p>{% highlight ruby %}
class CanMethod
  def initialize(params, body)</p>

<pre><code>@params = params
@body = body
</code></pre>

<p>  end</p>

<p>  def call(receiver, arguments)</p>

<pre><code>@body.eval(Context.new(receiver))
</code></pre>

<p>  end
end{% endhighlight %}</p>

<p>When your program calls a method, a portion of the AST is evaluated. The body of the method object is called with the provided parameters in the context of the method receiver. For ruby newbies, the receiver is the object on the left side of the method call &mdash; ie. in foo.bar(3), foo is the receiver and bar is called with the parameter of 3 in the context of foo.  The runtime will create a new context for the method (recall that ruby is block scoped, meaning that all variables and blocks within the method are confined to that method&hellip; mostly).</p>

<p>{% highlight ruby %}
class Context
  attr_reader :locals, :current_self, :current_class</p>

<p>  @@constants = {}</p>

<p>  def initialize(current_self, current_class=current_self.can_class)</p>

<pre><code>@locals = {}
@current_self = current_self
@current_class = current_class
</code></pre>

<p>  end
end{% endhighlight %}</p>

<p>The context contains all the local variables for the scope as well as a reference to what object is self, and which is super. We are getting very close to putting all these pieces together!</p>

<p>Awesome</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parcel Parser]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/parcel-parser/"/>
    <updated>2013-08-16T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/parcel-parser</id>
    <content type="html"><![CDATA[<p>On the last episode, I described how to label chunks of code for processing through a parser. Strings are labeled as &lsquo;STRING&rsquo;, class definitions as &lsquo;A&rsquo; + &lsquo;CONSTANT&rsquo;, etc.</p>

<h2>What is a parser?</h2>

<p>A parser separates and analyzes a piece of text according to a set of rules specified by a formal grammar. The analysis is performed by assembling the tokenized code into an Abstract Syntax Tree (AST) &ndash; a tree of nodes that represent what the code means to the language. The AST evaluates the nodes in a similar manner to order of operations in math: each token is placed on the evaluation tree, and expressions are evaluated by reducing each branch in order.</p>

<p>The parser itself is can be written by hand, but I am using RACC: an LALR (Look Ahead, Left to right, Reverse) parser written by <a href="https://github.com/tenderlove/racc">tenderlove</a> to generate Ruby programs. How do we specify a grammar that RACC will understand?</p>

<!--more-->


<p>Each rule is formatted in the following way:
{% highlight bash linenos%}
RuleName:
  OtherRule TOKEN AnotherRule    { code to run }
| OtherRule                      { &hellip; }
; {% endhighlight %}</p>

<p>It is similar to an if/else statement that captures all possible expressions beginning with the most specific (ie: an expression with TWO rules matches line 2) to more general (all other single expressions are captured on line 3). When a token matches a rule, the code in the attached code block is run.</p>

<p>The code blocks correspond to instructions on how to treat matching tokens. For example, the grammar should specify what happens when the code contains a class definition, labeled with &lsquo;A&rsquo; + &lsquo;CONSTANT&rsquo;.</p>

<p>{% highlight ruby %}
&hellip;</p>

<h1>Class definition</h1>

<p>Class:
  A CONSTANT Block { result = ClassNode.new(val[1], val[2]) }
;
&hellip; {% endhighlight %}</p>

<p>When the parser catches a class token it will create a new ClassNode with the class name (CONSTANT) and the block as arguments. The val[] array refers to the grammar rule [A, CONSTANT, Block].</p>

<p>Some tokens are parsed very close to AS IS:</p>

<p>{% highlight ruby %}
Literal:
  NUMBER { result = LiteralNode.new(val[0]) }
| STRING { result = LiteralNode.new(val[0]) }
| TRUE   { result = LiteralNode.new(true) }
| FALSE  { result = LiteralNode.new(false) }
| NIL    { result = LiteralNode.new(nil) }
; {% endhighlight %}</p>

<p>Each literal triggers the creation of a new LiteralNode with its value as the only argument.</p>

<p>The Nodes are outlined in a Nodes class, where the rules of evaluation are defined.</p>

<p>{% highlight ruby %}
&hellip;
class ClassNode
  def initialize(name, body)</p>

<pre><code>@name = name
@body = body
</code></pre>

<p>  end</p>

<p>  def eval(context)</p>

<pre><code>eh_class = CanadianClass.new
context[@name] = eh_class
@body.eval(Context.new(eh_class, eh_class))
eh_class
</code></pre>

<p>  end
end
&hellip;
{% endhighlight %}</p>

<p>A ClassNode is initialized with two params (recall from the grammar: ClassNode.new(val[1], val[2])), the class name and its code block. The context is like scope &ndash; it can hold modules, classes, methods, attributes, aliases, requires, and includes. Classes, modules, and files are all Contexts (definition from <a href="http://ruby-doc.org/stdlib-1.8.6/libdoc/rdoc/rdoc/RDoc/Context.html">Rdocs</a>). Evaluation of a ClassNode begins by assigning the class to a context and evaluating the code block, which adds more contexts. In this way, a tree structure is formed &ndash; an AST &ndash; which does all the interpreting work for the new language.</p>

<p>When the grammar and node definitions are complete, RACC will generate a parser:
{% highlight ruby %}
$ racc -vo parser.rb grammar.y {% endhighlight %}</p>

<p>The parser is a relatively obtuse set of methods and state transition tables, and when you run code through the parser you get an AST that follows the grammar you have defined.</p>

<p>So, now I have a lexer and a parser, but I still can&rsquo;t run my code. I need to define a runner class that will put all these parts together, but first, I need a break.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flex Your Lexer]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/flex-your-lexer/"/>
    <updated>2013-08-15T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/flex-your-lexer</id>
    <content type="html"><![CDATA[<p>A Lexer is a ruby class with a single method: tokenize(). Its purpose is to label each chunk of code with a particular token. Strings are labeled as strings, numbers as numbers, and class names as constants. For example,</p>

<p>{% highlight ruby %}
Lexer.new.tokenize(&ldquo;string&rdquo;)</p>

<h1>=>[[:STRING, &ldquo;string&rdquo;]]</h1>

<p>Lexer.new.tokenize(&ldquo;True&rdquo;)</p>

<h1>=>[[:CONSTANT, &ldquo;True&rdquo;]]</h1>

<p>Lexer.new.tokenize(&ldquo;a Car&rdquo;)</p>

<h1>=>[[:A, &lsquo;a&rsquo;], [:CONSTANT, &lsquo;Car&rsquo;]])</h1>

<p>Lexer.new.tokenize(&ldquo;+&rdquo;)</p>

<h1>=>[[&ldquo;+&rdquo;, &ldquo;+&rdquo;]]</h1>

<p>{% endhighlight %}</p>

<p>&ldquo;Lexing&rdquo; is accomplished using regular expressions. The lexer treats the text string of your code like a shish kabob &ndash; it slides recognizable chunks off the skewer one at a time and categorizes them (onion, pepper, method definition, etc).</p>

<!--more-->


<p>{% highlight ruby %}
class Lexer
  KEYWORDS = [&lsquo;a&rsquo;, &lsquo;can&rsquo;, &lsquo;if&rsquo;, &lsquo;else&rsquo;, &lsquo;while&rsquo;, &lsquo;true&rsquo;, &lsquo;false&rsquo;, &lsquo;nil&rsquo;]</p>

<p>  def tokenize(code)</p>

<pre><code>code.chomp!
i = 0
tokens = []

while i &lt; code.size
  chunk = code[i..-1]

  # checks keywords
  if identifier = chunk[/\A(eh\?)/, 1]
    tokens &lt;&lt; ['}', '}']
    i += identifier.size

  elsif identifier = chunk[/\A([a-z]\w*)/, 1]
    if KEYWORDS.include?(identifier)
      tokens &lt;&lt; [identifier.upcase.to_sym, identifier]
    else
      tokens &lt;&lt; [:IDENTIFIER, identifier]
    end
    i += identifier.size
</code></pre>

<p>&hellip;{% endhighlight %}
In this example lexer I have defined my list of keywords, removed the trailing newline, and begun peeling identifiable chunks off the code example.
* If the code chunk matches an &lsquo;eh?&rsquo; it will add a closing brace to the token array.
* If the code chunk matches a KEYWORD it will be upcased and labeled as a keyword and added to the token array.
* If the code chunk matches any word of lowercase letters it will be labeled as an IDENTIFIER and added to the token array.</p>

<p>I continued defining regex rules until I was able to completely tokenize a class definition:</p>

<p>{% highlight ruby %}
code = &lt;&lt;-EOS
a Canadian
  can curl</p>

<pre><code>if skip:
  say 'Hurry!'
eh?
</code></pre>

<p>  eh?
eh?
EOS
&hellip;
Lexer.new.tokenize(code)</p>

<h1>=> [[:A, &ldquo;a&rdquo;], [:CONSTANT, &ldquo;Canadian&rdquo;], [:CAN, &ldquo;can&rdquo;], [:IDENTIFIER, &ldquo;curl&rdquo;], [:IF, &ldquo;if&rdquo;], [:IDENTIFIER, &ldquo;skip&rdquo;], [&ldquo;{&rdquo;, &ldquo;{&rdquo;], [:IDENTIFIER, &ldquo;say&rdquo;], [:STRING, &ldquo;Hurry!&rdquo;], [&ldquo;}&rdquo;, &ldquo;}&rdquo;], [&ldquo;}&rdquo;, &ldquo;}&rdquo;], [&ldquo;}&rdquo;, &ldquo;}&rdquo;]]{% endhighlight %}</h1>

<p>Now that I have an array of tokens, it is time to write my grammar laws that will tell the parser what to do with them.</p>

<p>Awesome</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Canadian Flair]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/canadian-flair/"/>
    <updated>2013-08-10T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/canadian-flair</id>
    <content type="html"><![CDATA[<p>For my last month at code school, I have decided to learn what it takes to develop a new programming language. Having been teased for my Canadian accent, I thought it appropriate to incorporate some idiomatic Canadianisms, and call my language Eh? Deciding what actual features I want to implement in my programming language is an interesting task, and I think I have narrowed it down to a couple of standard rules and a couple wacky ones:</p>

<h3>Rules for Eh?</h3>

<ul>
<li>blocks of code are delimited by &lsquo;:&rsquo; and &lsquo;eh?&rsquo;</li>
<li>classes are declared using &ldquo;A&rdquo; keyword</li>
<li>methods are defined using &ldquo;CAN&rdquo; keyword</li>
<li>lowercase identifiers are local variables or method names</li>
<li>capitalized identifiers are global variables</li>
<li>no parens for args</li>
<li>last value evaluated in return value</li>
<li>everything is an object</li>
</ul>


<!--more-->


<h1>Steps for building an interpreted language</h1>

<ol>
<li>This code has to be provided as input to a lexer.</li>
<li>The lexer will convert that input into tokens.</li>
<li>The parser will organize those tokens into a tree of nodes.</li>
<li>The runtime will evaluate the nodes using ruby.</li>
</ol>


<h3>Prototype</h3>

<p>Here is what I would like the final result to look like:</p>

<p>{% highlight ruby %}
a Canadian
  with toque
  with scarf
  with broom</p>

<p>  can curl</p>

<pre><code>if skip:
  say "Hurry!"
eh?
if lead:
  pass
eh?
say "How social the game..."
</code></pre>

<p>  eh?</p>

<p>  can say_aboot:</p>

<pre><code>say "What's it all aboot?"
</code></pre>

<p>  eh?
eh?
{% endhighlight %}</p>

<p>With this vague action plan and <a href="http://createyourproglang.com/?hop=rubyinside">&ldquo;Create Your Own Programming Language&rdquo;</a> by Marc-Andre Cournoyer in hand, off we go!</p>

<p>Awesome</p>
]]></content>
  </entry>
  
</feed>
