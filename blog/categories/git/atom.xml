<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | keighty]]></title>
  <link href="http://www.katieleonard.ca/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://www.katieleonard.ca/"/>
  <updated>2014-02-21T08:04:52-08:00</updated>
  <id>http://www.katieleonard.ca/</id>
  <author>
    <name><![CDATA[katie leonard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Afraid of Commitment]]></title>
    <link href="http://www.katieleonard.ca/blog/2014/afraid-of-commitment/"/>
    <updated>2014-02-04T08:04:27-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2014/afraid-of-commitment</id>
    <content type="html"><![CDATA[<h3>or, how to not fubar your git history</h3>

<p>As with all the git lessons I have learned, this one started with a huge mistake. I had merged a commit to master that was breaking pages I didn&rsquo;t know existed. The sage developer sitting on my right shoulder told me that since I was unsure of how to fix the problem I should revert the offending commit forthwith. <!--more--></p>

<p>I had two choices of commit to revert:</p>

<ol>
<li>remove the offending commit from the branch history</li>
<li>remove the merge commit, where the broken code had infiltrated master</li>
</ol>


<p>While the former is like a surgical excision of a moment in history (eternal sunshine of a spotless git history?), the latter will preserve your branch history, and the context surrounding the changes made. I like a lot of context, so I chose to revert the merge commit.</p>

<p>When you undo a merge, git doesn&rsquo;t know how to reassign the branches. Was the left one master? The right? Does git know left from right? Who is on first? Take the guesswork out of the equation</p>

<p><code>bash
$ git checkout -b revert_branch_name
$ git revert -m 1 &lt;SHA of commit to be reverted&gt;
</code></p>

<p>Warning: If you donâ€™t make the new branch first, you will mess up your merge history on master. Trust me. Just make the branch first. Now you can ensure that your test suite will pass with the commit reverted before you do something silly, like merge even more breakage into master. Crisis averted.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Add -p]]></title>
    <link href="http://www.katieleonard.ca/blog/2014/git-add-p/"/>
    <updated>2014-02-01T20:51:09-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2014/git-add-p</id>
    <content type="html"><![CDATA[<p>I learned a new tool that has quickly become an essential part of my workflow. <code>git add -p</code><!--more--> lets you add small hunks of modified code to the index from your working tree in order to prepare your next commit.</p>

<p>The best refactors are small atomic changes, and while I may not always work incrementally, I still want my git history to reflect the ideal. I use <code>git add -p</code> before every commit to ensure that each code change is intentional.</p>

<p>``` bash An example from my latest test project.
$ git add -p
diff &mdash;git a/send.rb b/send.rb
index 5e89eaf..a0f25b6 100644
&mdash;&ndash; a/send.rb
+++ b/send.rb
@@ -17,5 +17,5 @@ queue = channel.queue(&ldquo;hello&rdquo;)
 channel.default_exchange.publish(&ldquo;Hello world!&rdquo;, :routing_key => q.name)
 puts &ldquo; [x] Sent &lsquo;Hello World!&rsquo;&rdquo;</p>

<p>&ndash;# close the connection
-conn.close
\ No newline at end of file
+#close the connection
+connection.close
Stage this hunk [y,n,q,a,d,/,e,?]?
```</p>

<p>Woah &mdash; that is a lot of information&hellip; lets go through by the numbers:</p>

<ol>
<li>the initial command</li>
<li>tells me that it is showing the changes made in the send.rb file. &lsquo;a&rsquo; is the version already in the commit history, and &lsquo;b&rsquo; is the copy in the working directory.</li>
<li>shows the commit SHA range for this branch</li>
<li>tells me that lines marked with a &lsquo;&ndash;&rsquo; are from the committed version of send.rb</li>
<li>tells me that lines marked with a &lsquo;+&rsquo; are from the working directory version of send.rb</li>
<li><code>@@ -17,5 +17,5 @@</code> indicates that the hunk under scrutiny begins at line 17 of the committed version (&lsquo;-17&rsquo;) and affects 5 lines. It corresponds to the working directory version starting at line 17 (&lsquo;+17&rsquo;), also affecting 5 lines.</li>
<li>the remaining lines contain the details of the changes in the hunk.</li>
</ol>


<h3>Know your options</h3>

<p>Now that you have a hunk, what can you do with it?</p>

<p><code>bash Type '?' to learn what you can do with your hunk
...
Stage this hunk [y,n,q,a,d,/,e,?] ?
y - stage this hunk
n - do not stage this hunk
q - quit, do not stage this hunk nor any of the remaining ones
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
</code></p>

<p>The first few options are obvious choices &mdash; <code>y</code> (&ldquo;Yes, please!&rdquo;), and <code>n</code> (&ldquo;What was I thinking there?&rdquo;), as well as <code>q</code> (&ldquo;Hey, Jane! Get me off this crazy thing!&rdquo;).</p>

<p>I haven&rsquo;t quite got a handle on the middle options, but I have skimmed down and used <code>s</code> to split the hunk into smaller pieces. Split will only divide a hunk if there is a logical place for separation, like a gap between changes. For real index-finesse and line-by-line control you have to&hellip; edit the hunk (gasp).</p>

<p>Seasoned veterans may blanch at the thought of editing a hunk without a GUI, but I have discovered the secret to command-line-hunk-editing-prowess. The secret is:</p>

<h2>Read the instructions</h2>

<p>Revisiting the earlier example, I choose <code>e</code> to edit my hunk. I think the original comment on line 10 is better than the new one on line 13 (spacy == better). Selecting <code>e</code> opens your editor of choice with the now familiar hunk, along with&hellip;</p>

<p>Lo, and behold! Instructions after the hunk!</p>

<p><img src="/images/addp-hunk-edit_diff-8.png"></p>

<p>Simple enough:</p>

<ul>
<li><code>-# close the connection</code> becomes <code># close the connection</code> &mdash; mind the space!</li>
<li>remove <code>+#close the connection</code> entirely</li>
<li>save and close.</li>
</ul>


<p>Success? If you have done everything right, the hunk will be staged and git will move on to the next hunk in your working directory. If you have made an error you will see the following message:</p>

<p><code>
Your edited hunk does not apply.
Edit again (saying "no" discards!) [y/n]?
</code></p>

<p>Aw nuts. <code>y</code> will let you amend your transgressions (did you remember to save? did you forget to leave a space in place of the &lsquo;&ndash;&rsquo;?), and <code>n</code> will abandon your changes and take you back to the drawing board, where you are free to transgress anew.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Retrieve: A Drama]]></title>
    <link href="http://www.katieleonard.ca/blog/2014/git-retrieve/"/>
    <updated>2014-01-23T20:47:46-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2014/git-retrieve</id>
    <content type="html"><![CDATA[<p>Have you ever deleted a file on impulse, only to wake up with remorse later? It doesn&rsquo;t matter if later is the next morning or the next week, thanks to git you have the power to reanimate gone-but-not-forgotten files. Nothing is <del>ever</del> EVER lost with git. So how do you retrieve a file that has been deleted in a previous commit?</p>

<!--more-->


<p><a href="http://stackoverflow.com/a/953573">stackoverflow</a> has a few suggestions, and I like this one the best:</p>

<h3>Git Drama in Three Acts</h3>

<p><code>bash Act 1 Scene 1: foo.bar Folly
$ cd ~/very_important_project/
$ touch readme.md index.html foo.bar
$ git commit -am "These changes are AWESOME."
[master (root-commit) 9155e0b] These changes are AWESOME.
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 foo.bar
 create mode 100644 index.html
 create mode 100644 readme.md
</code>
but wait! <code>foo.bar</code>?! that is just crazy talk?</p>

<p><code>bash Act 1 Scene 2: Regret
$ git rm foo.bar
rm 'foo.bar'
$ git add -u
$ git commit -m "I have made a huge mistake."
[master b045a52] I have made a huge mistake.
 0 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 foo.bar
</code></p>

<p>Everything seems back to normal!</p>

<p><code>bash Act 2 Scene 1: I have made good life-choices
$ echo "#I rock and I am smug about it!" &gt; bar.rb
$ git commit -am "This work is the BOMB."
[master 3535f28] This work is the BOMB.
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 bar.rb
$ cat foo.bar
cat: foo.bar: No such file or directory you heartless creature!
</code></p>

<p>but wait! there is no bar without a foo! where is my foo.bar? How can I find it? I have to find the commit where it was deleted, but how? What if I list out the commits that include a deleted file?</p>

<p>```bash Act 2 Scene 2: Regret
$ git log &mdash;diff-filter=D &mdash;summary
commit b045a528b4a0824f63562cad867b264983b32c7c
Author: keighty <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x6b;&#x65;&#105;&#x67;&#104;&#116;&#121;&#x2e;&#x6c;&#101;&#x6f;&#110;&#97;&#114;&#x64;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#107;&#101;&#x69;&#x67;&#x68;&#x74;&#121;&#46;&#x6c;&#101;&#111;&#110;&#97;&#114;&#x64;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a>
Date:   Wed Jan 22 20:46:16 2014 -0800</p>

<pre><code>I have made a huge mistake.
</code></pre>

<p> delete mode 100644 foo.bar
```</p>

<p>There you are! in commit b045a528. The summary option shows the details, so you can see what files were deleted, when, and by whom. In some cases, there may be more than one change in a commit, so using <code>commitSHA~1 &lt;filename&gt;</code> will pluck the one precious deleted file from the commit and restore it to your working tree.</p>

<p>```bash Act 3: foo.bar&rsquo;s Return
$ git checkout b045a528~1 foo.bar
$ git status</p>

<h1>On branch master</h1>

<h1>Changes to be committed:</h1>

<h1>(use &ldquo;git reset HEAD <file>&hellip;&rdquo; to unstage)</h1>

<p>#</p>

<h1>new file:   foo.bar</h1>

<p>#
$ git commit -am &ldquo;Together at last, together forever.&rdquo;
[master 8492eac] Together at last, together forever.
 0 files changed, 0 insertions(+), 0 deletions(&ndash;)
 create mode 100644 foo.bar
```</p>

<p>EXEUNT.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get Clean]]></title>
    <link href="http://www.katieleonard.ca/blog/2014/get-clean/"/>
    <updated>2014-01-13T21:29:03-08:00</updated>
    <id>http://www.katieleonard.ca/blog/2014/get-clean</id>
    <content type="html"><![CDATA[<p>I experiment a lot before I choose an implementation I like. I am sure I am not alone in making a few (or many) false starts, and yet feeling sick at the thought of deleting any code. What if one of those paths I started down was the right one? This loss aversion often leads to working trees of non-working code, and <code>git stash</code>-es that I will never revisit. If I stop myself from going too far down yet another road without an end in sight, attempts to clean up my working directory often stall miserably at the end of a <code>git checkout .</code>:<!--more--></p>

<p>```bash
On branch intelligent_branch_name</p>

<h1>Untracked files:</h1>

<h1>(use &ldquo;git add <file>&hellip;&rdquo; to include in what will be committed)</h1>

<p>#</p>

<h1>../test/yay_I_wrote_tests.rb</h1>

<h1>../helpers/yay_I_wrote_a_helper.rb</h1>

<h1>../helpers/how_many_helpers_did_I_write.rb</h1>

<h1>../views/i_dont_remember_creating_this_file.rb</h1>

<h1>../models/oh_thats_where_that_went.rb</h1>

<p>```</p>

<p>Once upon a time, I would click my way through <code>rm</code> after <code>rm</code>. A small improvement in <code>rm</code> efficiency came when I discovered I could <code>rm</code> more than one file at a time (don&rsquo;t judge me, I am new at this). Still, the biggest break-through came when a coworker, perhaps observing my struggles, pointed me to <a href="http://ndpsoftware.com/git-cheatsheet.html">git-cheatsheet</a> &mdash; a interactive visual tool to display the relevant commands for each stage of my git workflow.</p>

<h3>Enter <code>git clean</code></h3>

<p>Git clean is a force to be reckoned with, and not just because it doesn&rsquo;t do anything unless you force it.</p>

<p><code>bash Use the -n flag to describe the action the cleaner would take linenos:false
$ git clean -n
Would remove ../helpers/yay_I_wrote_a_helper.rb
Would remove ../helpers/how_many_helpers_did_I_write.rb
Would remove ../views/i_dont_remember_creating_this_file.rb
Would remove ../models/oh_thats_where_that_went.rb
$
</code></p>

<p><code>bash Use the -f flag to force the cleanup linenos:false
$ git clean -f
removed ../helpers/yay_I_wrote_a_helper.rb
removed ../helpers/how_many_helpers_did_I_write.rb
removed ../views/i_dont_remember_creating_this_file.rb
removed ../models/oh_thats_where_that_went.rb
$
</code></p>

<p>Now I can be as crufty as I want to be in my working tree, because <code>git</code> will be there to clean up the mess.</p>

<p>Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git-Picking]]></title>
    <link href="http://www.katieleonard.ca/blog/2013/git-picking/"/>
    <updated>2013-07-24T22:29:03-07:00</updated>
    <id>http://www.katieleonard.ca/blog/2013/git-picking</id>
    <content type="html"><![CDATA[<h4>or, How to mine for cherries with Git</h4>

<p>When I work on an experimental feature in a project branch, I have often found that I will have a mixture of commits I would like to keep, and commits that I wish had never happened.
Using the principle of only committing atomic changes, and enjoying the fruits of your detailed-commit-message labour, there is a way to extract the gold from the ore, so to speak.</p>

<!--more-->


<h2>Locate the gold</h2>

<p>Checkout the branch that contains your experiment, and use git log to get a list of all the commits:</p>

<p><div>
  <pre><code class='bash'>$ git checkout form_feature_branch
$ git log &amp;mdash;pretty=oneline
a83f4c3aa5d800f846d075748a79a326e0971f67 reorg gemfile
197964c091905a76f2172ca11fcbd49ccfb83c67 adds blog.db
a793fe00c50a5956c5e9f7be48ac5a9861b1eb95 adds forme form to edit&amp;hellip;
8394b37494b63754f42ecaf19244fe6d8a36942f adds gitignore for db &amp;hellip;
c52a6fd3f1706584ce3e47abf49ed627a1e28fd3 adds bundler gem for manag&amp;hellip;
1686664c4a98221ea04377bcbcf946e62a9f1cfa removes gems for simple&amp;hellip;
034d309a612dcce6f10bb55f0da2e78b2f7c10b1 adds cells to project
&amp;hellip;</code></pre>
</div>
</p>

<p>In form_feature_branch I was testing out different implementations of form generation in erb views. I tried a couple of different gems and found one that suits my sinatra project: <a href="https://github.com/jeremyevans/forme">Forme</a> is easy to use with or without models, and has great sinatra integration and documentation. Also along the way, I discovered how to include bundler for managing file dependencies and did some minor refactoring of my Gemfile.</p>

<p>I wanted to keep the gem reorganization, as well as the forme, bundler, and gitignore commits, so I made this list of keeper-commits:</p>

<p><div>
  <pre><code class='bash'>a83f4c3aa5d800f846d075748a79a326e0971f67 reorg gemfile
a793fe00c50a5956c5e9f7be48ac5a9861b1eb95 adds forme form to edit&amp;hellip;
c52a6fd3f1706584ce3e47abf49ed627a1e28fd3 adds bundler gem for manag&amp;hellip;
8394b37494b63754f42ecaf19244fe6d8a36942f adds gitignore for db &amp;hellip;</code></pre>
</div>
</p>

<p>Everything else is cruft.</p>

<h2>Extract the gold</h2>

<p>With this list of golden commits in hand, checkout a fresh branch and cherry-pick the commits you like!
<div>
  <pre><code class='bash'>$ git checkout -b form_feature_additions
$ git cherry-pick &amp;lt;commit_identifier&gt;</code></pre>
</div>
</p>

<p>Do this command for each good commit:
<div>
  <pre><code class='bash'>$ git cherry-pick a83f4c3aa5d800f846d075748a79a326e0971f67
[master form_feature_additions] reorg gemfile
 1 file changed, 4 insertions(+), 2 deletions(&amp;ndash;)
 changed mode 100644 Gemfile
$ git cherry-pick a793fe00c50a5956c5e9f7be48ac5a9861b1eb95
[master form_feature_additions] adds forme form to edit&amp;hellip;
&amp;hellip;
$ git cherry-pick c52a6fd3f1706584ce3e47abf49ed627a1e28fd3
[master form_feature_additions] adds bundler gem for manag..
&amp;hellip;
$ git cherry-pick 8394b37494b63754f42ecaf19244fe6d8a36942f
[master form_feature_additions] adds gitignore for db &amp;hellip;
&amp;hellip;</code></pre>
</div>
</p>

<p>If you look at your git status you will see</p>

<p><div>
  <pre><code class='bash'>&lt;/p&gt;

&lt;h1&gt;On branch form_feature_additions&lt;/h1&gt;

&lt;h1&gt;Your branch is ahead of &amp;lsquo;origin/master&amp;rsquo; by 4 commits.</code></pre>
</div>
</h1>

<h2>Profit</h2>

<p>Now you can merge this branch with master, or continue fleshing out the feature on a clean branch, keeping only the good stuff and abandoning the bad, making experimentation easy.</p>

<p>AWESOME</p>
]]></content>
  </entry>
  
</feed>
